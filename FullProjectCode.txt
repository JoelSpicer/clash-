--- START OF PROJECT DUMP ---


========================================
FILE PATH: res://Scripts/ActionNode.gd
========================================
extends TextureButton

signal action_clicked(node_id, node_name)
signal hovered(node_id, node_name)
signal exited()

# Define status constants for readability
const STATUS_LOCKED = 0
const STATUS_AVAILABLE = 1
const STATUS_OWNED = 2# In Library, not in Deck
const STATUS_EQUIPPED = 3 # In Active Deck

var id: int = 0
var action_name: String = ""
var status: int = STATUS_LOCKED

# Variables to hold the visual parts
var label: Label
var background: Panel

func _ready():
	# 1. VISUAL REPAIR
	if get_child_count() == 0:
		_build_ui()
	else:
		label = get_node_or_null("Label")
		background = get_node_or_null("Panel")
	
	# --- FIX 1: FORCE MOUSE IGNORE ON CHILDREN ---
	# This ensures the label/panel never block the hover signal
	if label: label.mouse_filter = Control.MOUSE_FILTER_IGNORE
	if background: background.mouse_filter = Control.MOUSE_FILTER_IGNORE
	# ---------------------------------------------
	
	# 2. SIZE REPAIR
	if size.x < 40 or size.y < 40:
		custom_minimum_size = Vector2(50, 50)
		size = Vector2(50, 50)
		
# --- AUDIO CONNECTIONS ---
	# Add hover sound (using the existing signal or a new connection)
	mouse_entered.connect(func(): 
		hovered.emit(id, action_name)
		AudioManager.play_sfx("ui_hover", 0.2)
	)
	
	# Add click sound
	pressed.connect(func():
		AudioManager.play_sfx("ui_click")
	)
	mouse_exited.connect(func(): exited.emit())	

func _build_ui():
	background = Panel.new()
	background.mouse_filter = Control.MOUSE_FILTER_IGNORE
	background.set_anchors_and_offsets_preset(Control.PRESET_FULL_RECT)
	add_child(background)
	
	label = Label.new()
	label.text = name
	label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	label.vertical_alignment = VERTICAL_ALIGNMENT_CENTER
	label.mouse_filter = Control.MOUSE_FILTER_IGNORE
	label.set_anchors_and_offsets_preset(Control.PRESET_FULL_RECT)
	add_child(label)

func setup(new_id: int, new_name: String):
	id = new_id
	action_name = new_name
	if label: label.text = str(id)
	tooltip_text = ""

func set_status(new_status: int):
	status = new_status
	disabled = false
	
	if background:
		match status:
			STATUS_LOCKED:
				background.modulate = Color(0.2, 0.2, 0.2) # Dark Grey
			STATUS_AVAILABLE:
				background.modulate = Color(1, 1, 0)       # Yellow
			STATUS_OWNED:
				background.modulate = Color(0.5, 0.5, 0.5) # Grey (Owned but inactive)
			STATUS_EQUIPPED:
				background.modulate = Color(0.2, 1.0, 0.2) # Bright Green (Active)

func _pressed():
	action_clicked.emit(id, action_name)


========================================
FILE PATH: res://Scripts/ActionTree.gd
========================================
extends Control

#region vars
# --- DATA ---
var action_tree_dict = {}     
var id_to_name = {}
var name_to_id = {}

const NODE_QUICK = 73
const NODE_TECHNICAL = 74
const NODE_PATIENT = 75
const NODE_HEAVY = 76

# --- SCENE REFS ---
@onready var nodes_layer = %NodesLayer
@onready var lines_layer = %LinesLayer

# --- STATE ---
var unlocked_ids: Array[int] = []
var owned_ids: Array[int] = []
var selected_class_id: int = 0
var is_class_locked: bool = false
var pending_unlock_id: int = 0 

# --- STATS TRACKING ---
var current_max_hp: int = 10
var current_max_sp: int = 3

# --- UI REFS ---
var ui_layer: CanvasLayer
var stats_label: Label 
var popup_card: Control
var card_scene = preload("res://Scenes/CardDisplay.tscn")

# Loadout Manager Refs
var loadout_panel: PanelContainer
var active_container: HBoxContainer
var reserve_container: HFlowContainer 
var toggle_btn: Button
#endregion

func _ready():
	action_tree_dict = ClassFactory.TREE_CONNECTIONS
	id_to_name = ClassFactory.ID_TO_NAME_MAP
	
	# Reverse lookup
	name_to_id.clear()
	for id in id_to_name:
		name_to_id[id_to_name[id]] = id
	
	# 1. SETUP NODES
	for child in nodes_layer.get_children():
		if child.has_method("setup"):
			var id = int(str(child.name)) 
			var a_name = id_to_name.get(id, "Unknown")
			child.setup(id, a_name)
			
			# Connect Signals
			if not child.action_clicked.is_connected(_on_node_clicked):
				child.action_clicked.connect(_on_node_clicked)
			if not child.hovered.is_connected(_on_node_hovered):
				child.hovered.connect(_on_node_hovered)
			if not child.exited.is_connected(_on_node_exited):
				child.exited.connect(_on_node_exited)

	# 2. CREATE UI LAYER (Draws on top of Tree)
	ui_layer = CanvasLayer.new()
	ui_layer.layer = 10 
	add_child(ui_layer)

	# 3. BUILD UI ELEMENTS
	_build_ui_overlay()
	_setup_popup()
	
	if RunManager.is_arcade_mode:
		print("ActionTree: Loading Arcade Run Data...")
		owned_ids = RunManager.player_owned_tree_ids.duplicate()
		if owned_ids.size() > 0: selected_class_id = owned_ids[0] 
		
		# Hide unnecessary buttons
		var btn_back = $TreeContainer/BackButton
		if btn_back: 
			if RunManager.current_level == 1:
				btn_back.visible = true
				btn_back.pressed.connect(_on_back_button_pressed)
			else:
				btn_back.visible = false # Hide for levels 2+ (No escaping!)
		
		# Update Confirm Button text
		var btn_confirm = $TreeContainer/ConfirmButton 
		if btn_confirm:
			if RunManager.free_unlocks_remaining > 0:
				btn_confirm.text = "PICK (" + str(RunManager.free_unlocks_remaining) + " LEFT)"
			else:
				btn_confirm.text = "UNLOCK & FIGHT"
		
		# Recalculate unlocks
		_unlock_neighbors(selected_class_id)
		for oid in owned_ids: 
			_unlock_neighbors(oid)
			
	else:
		_setup_for_current_player()
		var btn_back = $TreeContainer/BackButton
		if btn_back: btn_back.pressed.connect(_on_back_button_pressed)
	
	_refresh_loadout_manager()
	_update_tree_visuals()
	_recalculate_stats()
	lines_layer.queue_redraw()

# ==============================================================================
# UI CONSTRUCTION
# ==============================================================================

func _build_ui_overlay():
	

	# 2. Loadout Manager Panel (Bottom Center, Initially Hidden)
	# Created BEFORE the button so it renders BEHIND it
	loadout_panel = PanelContainer.new()
	loadout_panel.visible = false 
	
	# Anchor to Bottom Full Width
	loadout_panel.set_anchors_preset(Control.PRESET_BOTTOM_WIDE)
	loadout_panel.grow_vertical = Control.GROW_DIRECTION_BEGIN
	loadout_panel.custom_minimum_size.y = 300 
	
	# Add a background style
	var style = StyleBoxFlat.new()
	style.bg_color = Color(0.1, 0.1, 0.1, 0.95) 
	loadout_panel.add_theme_stylebox_override("panel", style)
	
	ui_layer.add_child(loadout_panel)
	
	# Layout
	var main_vbox = VBoxContainer.new()
	main_vbox.add_theme_constant_override("separation", 10)
	loadout_panel.add_child(main_vbox)
	
	# --- ROW 1: ACTIVE HAND ---
	var lbl_active = Label.new()
	lbl_active.text = "ACTIVE HAND (Max 8)"
	lbl_active.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	main_vbox.add_child(lbl_active)
	
	active_container = HBoxContainer.new()
	active_container.alignment = BoxContainer.ALIGNMENT_CENTER
	active_container.custom_minimum_size.y = 80
	active_container.add_theme_constant_override("separation", 10)
	main_vbox.add_child(active_container)
	
	# Separator
	var sep = HSeparator.new()
	main_vbox.add_child(sep)
	
	# --- ROW 2: RESERVES ---
	var lbl_reserve = Label.new()
	lbl_reserve.text = "RESERVE LIBRARY (Click to Equip)"
	lbl_reserve.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	main_vbox.add_child(lbl_reserve)
	
	# ScrollContainer
	var scroll = ScrollContainer.new()
	scroll.size_flags_vertical = Control.SIZE_EXPAND_FILL
	scroll.custom_minimum_size.y = 150
	main_vbox.add_child(scroll)
	
	reserve_container = HFlowContainer.new() 
	reserve_container.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	reserve_container.size_flags_vertical = Control.SIZE_EXPAND_FILL
	reserve_container.alignment = FlowContainer.ALIGNMENT_CENTER
	scroll.add_child(reserve_container)

	# 3. Toggle Button (Bottom Right)
	# Created LAST so it renders ON TOP
	toggle_btn = Button.new()
	toggle_btn.text = "EDIT LOADOUT"
	toggle_btn.set_anchors_and_offsets_preset(Control.PRESET_BOTTOM_RIGHT)
	toggle_btn.position -= Vector2(20, 20) # Padding
	toggle_btn.custom_minimum_size = Vector2(150, 50)
	toggle_btn.pressed.connect(_on_toggle_loadout_pressed)
	ui_layer.add_child(toggle_btn)

func _setup_popup():
	popup_card = card_scene.instantiate()
	popup_card.visible = false
	popup_card.mouse_filter = Control.MOUSE_FILTER_IGNORE 
	
	# FIX 1: Break existing layout constraints (The Warning Fix)
	# This ensures the card doesn't try to stretch to the full screen size
	popup_card.set_anchors_preset(Control.PRESET_TOP_LEFT)
	
	# Ensure it is on top of the UI layer
	popup_card.set_as_top_level(true) 
	popup_card.z_index = 4096 
	
	# FIX 2: Explicit Dimensions (Portrait Mode)
	popup_card.size = Vector2(250, 350)
	
	# FIX 3: Scale
	popup_card.scale = Vector2(0.6, 0.6) 
	
	ui_layer.add_child(popup_card)

# ==============================================================================
# LOGIC
# ==============================================================================

func _on_toggle_loadout_pressed():
	loadout_panel.visible = !loadout_panel.visible
	if loadout_panel.visible:
		toggle_btn.text = "CLOSE LOADOUT"
		_refresh_loadout_manager()
	else:
		toggle_btn.text = "EDIT LOADOUT"

func _refresh_loadout_manager():
	if not loadout_panel.visible: return
	
	# 1. Clear old buttons
	for c in active_container.get_children(): c.queue_free()
	for c in reserve_container.get_children(): c.queue_free()
	
	var active_deck: Array[ActionData] = []
	var library: Array[ActionData] = []
	
	# 2. Get Data
	if RunManager.is_arcade_mode:
		active_deck = RunManager.player_run_data.deck
		library = RunManager.player_run_data.unlocked_actions
	else:
		# Custom Mode Logic
		if selected_class_id == 0: return
		var class_enum = _get_class_enum_from_id(selected_class_id)
		
		# Starter cards
		var starters = ClassFactory.get_starting_deck(class_enum)
		library.append_array(starters)
		
		# Tree cards
		for id in owned_ids:
			if id >= 73: continue
			var c = ClassFactory.find_action_resource(id_to_name.get(id))
			if c: library.append(c)
			
		# Temporary: Custom Mode just fills active with everything.
		active_deck = library.duplicate()
		library = [] 

	# 3. Populate Active Row
	for card in active_deck:
		var btn = _create_card_button(card, true)
		active_container.add_child(btn)
		
	# 4. Populate Reserve Row
	# Logic: Show cards in 'library' that are NOT in 'active_deck'
	for card in library:
		if not _is_card_in_list(card, active_deck):
			var btn = _create_card_button(card, false)
			reserve_container.add_child(btn)

func _create_card_button(card: ActionData, is_active: bool) -> Button:
	var btn = Button.new()
	btn.custom_minimum_size = Vector2(60, 80)
	btn.tooltip_text = card.display_name + "\n" + card.description
	
	if card.icon:
		btn.icon = card.icon
		btn.icon_alignment = HORIZONTAL_ALIGNMENT_CENTER
		btn.expand_icon = true
	else:
		btn.text = card.display_name.left(3)
		
	if card.type == ActionData.Type.OFFENCE:
		btn.modulate = Color(1.0, 0.6, 0.6)
	else:
		btn.modulate = Color(0.6, 0.8, 1.0)
		
	# LOGIC:
	if is_active:
		# Click to UNEQUIP
		btn.pressed.connect(func(): _on_unequip_card(card))
	else:
		# Click to EQUIP
		btn.pressed.connect(func(): _on_equip_card(card))
		
	return btn

func _on_unequip_card(card: ActionData):
	if not RunManager.is_arcade_mode: return
	var player = RunManager.player_run_data
	
	if player.deck.size() <= 1:
		print("Cannot have empty deck.")
		return
		
	_remove_from_deck(player, card)
	_refresh_loadout_manager()
	_update_tree_visuals()
	_recalculate_stats()

func _on_equip_card(card: ActionData):
	if not RunManager.is_arcade_mode: return
	var player = RunManager.player_run_data
	
	if player.deck.size() >= ClassFactory.HAND_LIMIT:
		print("Hand Full! Remove a card first.")
		return
		
	player.deck.append(card)
	_refresh_loadout_manager()
	_update_tree_visuals()
	_recalculate_stats()

# --- TOOLTIP LOGIC ---
func _on_node_hovered(id, a_name):
	# CLASS NODES
	if id >= 73 and id <= 76:
		var class_info = _get_class_display_data(id)
		popup_card.set_card_data(class_info)
		popup_card.visible = true
		_update_popup_position()
		return

	# ACTION NODES
	var res = ClassFactory.find_action_resource(a_name)
	if res == null:
		res = ActionData.new()
		res.display_name = a_name
		res.description = "(File not created yet)"
		res.cost = 0
	
	if popup_card.has_method("set_card_data"):
		popup_card.set_card_data(res, res.cost)
	
	popup_card.visible = true
	_update_popup_position()

func _on_node_exited():
	popup_card.visible = false

func _process(_delta):
	if popup_card.visible:
		_update_popup_position()

func _update_popup_position():
	var m_pos = get_viewport().get_mouse_position()
	var screen_size = get_viewport_rect().size
	var card_size = popup_card.size * popup_card.scale
	var offset = Vector2(30, 30)
	
	var final_pos = m_pos + offset
	
	# Keep on screen
	if final_pos.x + card_size.x > screen_size.x:
		final_pos.x = m_pos.x - card_size.x - offset.x
	if final_pos.y + card_size.y > screen_size.y:
		final_pos.y = m_pos.y - card_size.y - offset.y
	
	popup_card.position = final_pos

# --- INTERACTION LOGIC (Tree) ---
func _on_node_clicked(id: int, _name: String):
	if RunManager.is_arcade_mode:
		
		# A. Clicking Owned Node -> Just Highlight
		if id in owned_ids:
			if id >= 73: return
			return
			
		# B. Drafting (Buying new)
		if id not in unlocked_ids: return 
		
		# --- FIX: PREVENT SELECTION IF NO UNLOCKS LEFT ---
		if RunManager.free_unlocks_remaining <= 0:
			# Optional: Visual feedback like a sound or shake
			print("No unlocks remaining! Click START FIGHT.")
			return
		# -------------------------------------------------
		
		pending_unlock_id = id
		
		_update_tree_visuals()
		
		# FIX: Force recalculate so the UI updates IMMEDIATELY with the new card preview
		_recalculate_stats()
		return
	
	# === CUSTOM DECK LOGIC ===
	if id >= 73: 
		if is_class_locked: return
		_select_class(id)
	elif id in owned_ids: 
		_try_deselect_action(id)
	elif id in unlocked_ids:
		owned_ids.append(id)
		_unlock_neighbors(id)
		_update_tree_visuals()
		_recalculate_stats()
	else:
		print("Locked!")

# --- HELPERS ---
func _is_card_in_list(card: ActionData, list: Array[ActionData]) -> bool:
	for c in list:
		if c.display_name == card.display_name: return true
	return false

func _select_class(class_id: int):
	selected_class_id = class_id
	owned_ids.clear()
	unlocked_ids.clear()
	owned_ids.append(class_id)
	_unlock_neighbors(class_id)
	_update_tree_visuals()
	_recalculate_stats()
	_refresh_loadout_manager()

func _recalculate_stats():
	var stats = { "hp": 10, "sp": 3 }
	
	if RunManager.is_arcade_mode:
		var p = RunManager.player_run_data
		
		# FIX: CALCULATE WITH PREVIEW
		# Create a temporary list of what we own + what we are about to buy
		var cards_to_count = p.unlocked_actions.duplicate()
		
		if pending_unlock_id != 0:
			var card_name = id_to_name.get(pending_unlock_id)
			var pending_card = ClassFactory.find_action_resource(card_name)
			if pending_card:
				cards_to_count.append(pending_card)
		
		stats = ClassFactory.calculate_stats_for_deck(p.class_type, cards_to_count)
		
	else:
		if selected_class_id == 0: return
		var class_enum = _get_class_enum_from_id(selected_class_id)
		var temp_deck = ClassFactory.get_starting_deck(class_enum)
		for id in owned_ids:
			if id >= 73: continue
			var card = ClassFactory.find_action_resource(id_to_name.get(id))
			if card: temp_deck.append(card)
		stats = ClassFactory.calculate_stats_for_deck(class_enum, temp_deck)
	
	current_max_hp = stats["hp"]
	current_max_sp = stats["sp"]

func _unlock_neighbors(node_id: int):
	if node_id in action_tree_dict:
		for neighbor_id in action_tree_dict[node_id]:
			if neighbor_id not in unlocked_ids and neighbor_id not in owned_ids:
				unlocked_ids.append(neighbor_id)

func _update_tree_visuals():
	for child in nodes_layer.get_children():
		var id = int(str(child.name))
		
		if id == pending_unlock_id:
			child.set_status(1) # Available (Selected)
			child.modulate = Color(1.5, 1.5, 1.5)
		else:
			child.modulate = Color.WHITE
			
			if id in owned_ids:
				# FIX: Force ALL owned nodes (including Class Node) to Green (Status 3)
				# We no longer distinguish between 'Equipped' and 'Reserve' on the tree visual itself.
				child.set_status(3) 
			elif id in unlocked_ids:
				child.set_status(1) # AVAILABLE (Yellow)
			else:
				child.set_status(0) # LOCKED

func _on_confirm_button_pressed():
	if RunManager.is_arcade_mode:
		
		# --- CASE 1: START FIGHT (Ready to go) ---
		if RunManager.free_unlocks_remaining <= 0 and pending_unlock_id == 0:
			
			# --- NEW: LOADOUT VALIDATION ---
			var has_offence = false
			var has_defence = false
			
			for card in RunManager.player_run_data.deck:
				if card.type == ActionData.Type.OFFENCE: has_offence = true
				if card.type == ActionData.Type.DEFENCE: has_defence = true
				
			if not has_offence or not has_defence:
				print("Cannot Start: Invalid Loadout.")
				# Visual Feedback using the Stats Label
				stats_label.text = "REQ: 1 OFFENCE & 1 DEFENCE!"
				stats_label.modulate = Color(1, 0.3, 0.3) # Red Warning
				
				# Reset the label after 2 seconds
				await get_tree().create_timer(2.0).timeout
				_recalculate_stats()
				return
			# -------------------------------
			
			RunManager.start_next_fight()
			return

		# --- CASE 2: DRAFTING (Spending Free Unlocks) ---
		# This now handles BOTH the initial draft AND level-up rewards
		if RunManager.free_unlocks_remaining > 0:
			if pending_unlock_id == 0: return 
			
			# 1. Commit
			RunManager.player_owned_tree_ids.append(pending_unlock_id)
			owned_ids.append(pending_unlock_id)
			
			var card_name = id_to_name.get(pending_unlock_id)
			var new_card = ClassFactory.find_action_resource(card_name)
			if new_card:
				RunManager.player_run_data.unlocked_actions.append(new_card)
				if RunManager.player_run_data.deck.size() < ClassFactory.HAND_LIMIT:
					RunManager.player_run_data.deck.append(new_card)
			
			# 2. Update
			_unlock_neighbors(pending_unlock_id)
			RunManager.free_unlocks_remaining -= 1
			pending_unlock_id = 0
			
			_refresh_loadout_manager()
			_update_tree_visuals()
			
			# 3. Heal & Stats (This covers the "Full Heal on Level Up" requirement)
			ClassFactory._recalculate_stats(RunManager.player_run_data)
			_recalculate_stats() # Update UI
			
			# 4. Check Status
			var btn = $TreeContainer/ConfirmButton
			if RunManager.free_unlocks_remaining <= 0:
				btn.text = "START FIGHT"
				#var btn_back = $TreeContainer/BackButton
				var btn_reset = $TreeContainer/ResetButton
				#if btn_back: btn_back.visible = false
				if btn_reset: btn_reset.visible = false
			else:
				btn.text = "PICK (" + str(RunManager.free_unlocks_remaining) + " LEFT)"
			return

		# --- CASE 3: FALLBACK ---
		if pending_unlock_id != 0:
			print("Warning: Unsanctioned purchase attempt blocked.")
			pending_unlock_id = 0
			_update_tree_visuals()
			return
			
	else:
		# --- CUSTOM DECK LAUNCH ---
		if selected_class_id == 0: return
		var final_character = CharacterData.new()
		match selected_class_id:
			73: final_character.class_type = CharacterData.ClassType.QUICK
			74: final_character.class_type = CharacterData.ClassType.TECHNICAL
			75: final_character.class_type = CharacterData.ClassType.PATIENT
			76: final_character.class_type = CharacterData.ClassType.HEAVY

		var base_deck = ClassFactory.get_starting_deck(final_character.class_type)
		var final_deck: Array[ActionData] = []
		final_deck.append_array(base_deck)
		
		for id in owned_ids:
			if id >= 73: continue 
			var a_name = id_to_name.get(id)
			var card_resource = ClassFactory.find_action_resource(a_name)
			if card_resource: final_deck.append(card_resource)
				
		final_character.deck = final_deck
		final_character.max_hp = current_max_hp
		final_character.max_sp = current_max_sp
		final_character.reset_stats()
		
		if GameManager.editing_player_index == 1:
			var p1_name = GameManager.get("temp_p1_name")
			final_character.character_name = p1_name if p1_name != "" else "Player 1"
			GameManager.next_match_p1_data = final_character
			
			if GameManager.p2_is_custom:
				GameManager.editing_player_index = 2
				_setup_for_current_player()
				return 
		else:
			var p2_name = GameManager.get("temp_p2_name")
			final_character.character_name = p2_name if p2_name != "" else "Player 2"
			GameManager.next_match_p2_data = final_character

		if GameManager.next_match_p2_data == null:
			GameManager.next_match_p2_data = ClassFactory.create_character(CharacterData.ClassType.HEAVY, "Bot")
			
		SceneLoader.change_scene("res://Scenes/VsScreen.tscn")

func _on_back_button_pressed():
	# --- NEW: Arcade Mode Cancel ---
	if RunManager.is_arcade_mode:
		print("Canceling Arcade Run...")
		RunManager.handle_loss() # Cleans up the arcade state variables
		SceneLoader.change_scene("res://Scenes/CharacterSelect.tscn")
		return
	# -------------------------------
	print("Canceling customization...")
	GameManager.next_match_p1_data = null
	GameManager.next_match_p2_data = null
	GameManager.editing_player_index = 1
	GameManager.p2_is_custom = false
	GameManager.temp_p1_preset = null
	GameManager.temp_p2_preset = null
	GameManager.temp_p1_name = ""
	GameManager.temp_p2_name = ""
	SceneLoader.change_scene("res://Scenes/MainMenu.tscn")

func _try_deselect_action(id_to_remove: int):
	var remaining_ids = owned_ids.duplicate()
	remaining_ids.erase(id_to_remove)
	
	# Flood fill check
	var reachable_count = 0
	var queue: Array[int] = [selected_class_id]
	var visited = {selected_class_id: true}
	
	while queue.size() > 0:
		var current = queue.pop_front()
		if current in remaining_ids: reachable_count += 1
		if current in action_tree_dict:
			for neighbor in action_tree_dict[current]:
				if neighbor in remaining_ids and not neighbor in visited:
					visited[neighbor] = true
					queue.append(neighbor)
	
	if reachable_count < remaining_ids.size():
		print("Cannot deselect: Disconnects tree!")
		return

	owned_ids.erase(id_to_remove)
	unlocked_ids.clear()
	for owner_id in owned_ids:
		_unlock_neighbors(owner_id)
		
	_update_tree_visuals()
	_recalculate_stats()
	_refresh_loadout_manager()

func _setup_for_current_player():
	var target_selection = 0
	if GameManager.editing_player_index == 1:
		target_selection = GameManager.get("temp_p1_class_selection")
	else:
		target_selection = GameManager.get("temp_p2_class_selection")
		
	owned_ids.clear()
	unlocked_ids.clear()
	is_class_locked = false
	
	if target_selection != null:
		var node_id = 0
		match target_selection:
			0: node_id = 76 
			1: node_id = 75 
			2: node_id = 73 
			3: node_id = 74 
			
		if node_id != 0:
			_select_class(node_id)
			is_class_locked = true 
			
	_refresh_loadout_manager()
	_update_tree_visuals()
	_recalculate_stats()
	lines_layer.queue_redraw()

func _get_class_display_data(id: int) -> ActionData:
	var data = ActionData.new()
	data.cost = 0 
	match id:
		76: 
			data.display_name = "CLASS: HEAVY"
			data.type = ActionData.Type.OFFENCE 
			data.description = "[b]Action: Haymaker[/b]\nOpener, Cost 3, Dmg 2, Mom 3\n[b]Action: Elbow Block[/b]\nBlock 1, Cost 2, Dmg 1\n[b]Passive: Rage[/b]\nPay HP instead of SP when low.\n[b]Growth:[/b]\n[color=#ff9999]Offence:[/color] +1 SP, [color=#99ccff]Defence:[/color] +2 HP\n[b]Speed:[/b] 1"
		75: 
			data.display_name = "CLASS: PATIENT"
			data.type = ActionData.Type.DEFENCE 
			data.description = "[b]Action: Preparation[/b]\nFall Back 2, Opp 1, Reco 1\n[b]Action: Counter Strike[/b]\nDmg 2, Fall Back 2, Parry\n[b]Passive: Keep-up[/b]\nSpend SP to prevent Fall Back.\n[b]Growth:[/b]\n[color=#ff9999]Offence:[/color] +1 HP, [color=#99ccff]Defence:[/color] +1 HP/SP\n[b]Speed:[/b] 2"
		73: 
			data.display_name = "CLASS: QUICK"
			data.type = ActionData.Type.OFFENCE
			data.description = "[b]Action: Roll Punch[/b]\nDmg 1, Cost 1, Mom 1, Rep 3\n[b]Action: Weave[/b]\nDodge 1, Fall Back 1\n[b]Passive: Relentless[/b]\nEvery 3rd combo hit gains Reco 1.\n[b]Growth:[/b]\n[color=#ff9999]Offence:[/color] +1 HP, [color=#99ccff]Defence:[/color] +2 SP\n[b]Speed:[/b] 4"
		74: 
			data.display_name = "CLASS: TECHNICAL"
			data.type = ActionData.Type.DEFENCE
			data.description = "[b]Action: Discombobulate[/b]\nCost 1, Dmg 1, Tiring 1\n[b]Action: Hand Catch[/b]\nBlock 1, Cost 1, Reversal\n[b]Passive: Technique[/b]\nSpend 1 SP to add Opener, Tiring, or Momentum to action.\n[b]Growth:[/b]\n[color=#ff9999]Offence:[/color] +1 SP/HP, [color=#99ccff]Defence:[/color] +1 SP\n[b]Speed:[/b] 3"
	return data

func _is_id_equipped(id: int) -> bool:
	if not RunManager.is_arcade_mode: return id in owned_ids
	var player = RunManager.player_run_data
	var c_name = id_to_name.get(id)
	for card in player.deck:
		if card.display_name == c_name: return true
	return false

func _is_card_equipped(player, card_data) -> bool:
	for c in player.deck:
		if c.display_name == card_data.display_name: return true
	return false

func _remove_from_deck(player, card_data):
	for i in range(player.deck.size()):
		if player.deck[i].display_name == card_data.display_name:
			player.deck.remove_at(i)
			return

func _get_class_enum_from_id(id: int) -> int:
	match id:
		73: return CharacterData.ClassType.QUICK
		74: return CharacterData.ClassType.TECHNICAL
		75: return CharacterData.ClassType.PATIENT
		76: return CharacterData.ClassType.HEAVY
	return CharacterData.ClassType.HEAVY

func _get_id_from_card(card: ActionData) -> int:
	if card.display_name in name_to_id:
		return name_to_id[card.display_name]
	return 0


========================================
FILE PATH: res://Scripts/AudioManager.gd
========================================
extends Node

# --- SOUND LIBRARY ---
# Replace these paths with your actual files later!
# If you don't have files yet, the game will just print a warning instead of crashing.
var sounds = {
	# UI
	"ui_hover": preload("res://Audio/UI/hover.wav"),
	"ui_click": preload("res://Audio/UI/click.wav"),
	"game_start": preload("res://Audio/UI/game_start.ogg"),
	
	# COMBAT
	"hit_light": preload("res://Audio/Combat/hit_light.wav"),
	"hit_heavy": preload("res://Audio/Combat/hit_heavy.wav"),
	"block": preload("res://Audio/Combat/block.wav"),
	"clash": preload("res://Audio/Combat/clash.wav"),
	"clash_win": preload("res://Audio/Combat/clash_win.wav"),
	"buff": preload("res://Audio/Combat/buff.wav"),
}

# --- PLAYER POOL ---
# We create 10 players so up to 10 sounds can happen at once.
var pool_size = 10
var sfx_players: Array[AudioStreamPlayer] = []

func _ready():
	# Create the pool of players
	for i in range(pool_size):
		var p = AudioStreamPlayer.new()
		p.bus = "SFX" # Make sure you have an 'SFX' bus in Audio tab, or default to 'Master'
		add_child(p)
		sfx_players.append(p)

# --- PUBLIC FUNCTION ---
func play_sfx(key: String, pitch_variance: float = 0.0):
	if not sounds.has(key):
		print_debug("Audio Key not found: " + key)
		return
		
	var stream = sounds[key]
	if not stream: return # File might be missing
	
	# Find a free player
	var player = _get_available_player()
	if player:
		player.stream = stream
		
		# Add random pitch variation for "Juice" (e.g., 0.9 to 1.1)
		if pitch_variance > 0:
			player.pitch_scale = randf_range(1.0 - pitch_variance, 1.0 + pitch_variance)
		else:
			player.pitch_scale = 1.0
			
		player.play()

func _get_available_player() -> AudioStreamPlayer:
	for p in sfx_players:
		if not p.playing:
			return p
	
	# If all are busy, steal the oldest one (index 0) and move it to back
	var p = sfx_players.pop_front()
	sfx_players.append(p)
	return p


========================================
FILE PATH: res://Scripts/BalanceTester.gd
========================================
extends Node

const REPORT_PATH = "user://detailed_balance_report.csv"

# We assume a neutral start for all tests to keep the baseline consistent.
# (You could expand this to test "Advantage State" vs "Disadvantage State" later)
const STARTING_SP = 4
const STARTING_HP = 7

func _ready():
	print("--- STARTING DETAILED BALANCE ANALYSIS ---")
	run_analysis()

func run_analysis():
	var all_actions = _load_all_actions()
	print("Loaded " + str(all_actions.size()) + " actions.")
	
	# 1. Expanded Header for Granular Data
	var headers = [
		"P1 Action", "P2 Action", "P1 Type", "P2 Type",
		"Priority Win",       # Who acted first?
		"P1 Cost", "P2 Cost", # How much they paid
		
		"P1 Raw Dmg", "P2 Raw Dmg",       # Potential Damage
		"P1 Dmg Negated", "P2 Dmg Negated", # Damage stopped by Block/Dodge/Parry
		"P1 Net Dmg", "P2 Net Dmg",       # Actual HP lost
		
		"P1 Def Value", "P2 Def Value",   # Block/Dodge amount used
		"P1 Def Wasted", "P2 Def Wasted", # Overkill defense (Efficiency metric)
		
		"P1 HP Delta", "P2 HP Delta",     # Net Health Change (Heal - Dmg)
		"P1 SP Delta", "P2 SP Delta",     # Net Stamina Change (Recover - Cost - Tiring)
		
		"Mom Shift",          # Direction of momentum
		"Tags"                # Special interactions (Reversal, Stun, etc)
	]
	
	var csv = ",".join(headers) + "\n"
	
	# 2. Simulate
	for p1_card in all_actions:
		for p2_card in all_actions:
			var row = _simulate_granular_clash(p1_card, p2_card)
			csv += row + "\n"
			
	# 3. Save
	var file = FileAccess.open(REPORT_PATH, FileAccess.WRITE)
	if file:
		file.store_string(csv)
		file.close()
		print("SUCCESS! Report saved to: " + ProjectSettings.globalize_path(REPORT_PATH))
		get_tree().quit()
	else:
		printerr("Failed to save report.")

func _simulate_granular_clash(c1: ActionData, c2: ActionData) -> String:
	var tags = []
	
	# --- A. SETUP COSTS & REPEATS ---
	var p1_reps = max(1, c1.repeat_count)
	var p2_reps = max(1, c2.repeat_count)
	
	var p1_total_cost = c1.cost * p1_reps
	var p2_total_cost = c2.cost * p2_reps
	
	# --- B. DETERMINE PRIORITY (Who is "Active") ---
	# "Active" means you successfully executed your move (didn't get interrupted).
	# In a clash, the loser might still act if they are Defensive, 
	# but for this sim, we mostly care about who wins the "Clash Priority".
	var priority_winner = "DRAW"
	
	if c1.type == ActionData.Type.OFFENCE and c2.type == ActionData.Type.DEFENCE:
		priority_winner = "P1"
	elif c2.type == ActionData.Type.OFFENCE and c1.type == ActionData.Type.DEFENCE:
		priority_winner = "P2"
	elif c1.cost < c2.cost:
		priority_winner = "P1"
	elif c2.cost < c1.cost:
		priority_winner = "P2"
	
	# Assume both act simultaneously for calculation, unless interrupted logic applies.
	# (In your game, Defence cards usually happen even if they lose priority, 
	# so we will simulate BOTH cards resolving effects against each other).
	var p1_active = true
	var p2_active = true
	
	# --- C. DODGE & PARRY CHECKS (The Negation Layer) ---
	
	# P1 defending against P2
	var p1_is_dodged = (c2.dodge_value > 0 and c2.dodge_value >= p1_total_cost)
	var p1_parries = c1.is_parry
	
	# P2 defending against P1
	var p2_is_dodged = (c1.dodge_value > 0 and c1.dodge_value >= p2_total_cost)
	var p2_parries = c2.is_parry
	
	if p1_is_dodged: tags.append("P1_Dodged")
	if p2_is_dodged: tags.append("P2_Dodged")
	
	# --- D. DAMAGE & DEFENSE CALCULATION ---
	
	# P1 Attacks -> P2 Defends
	var p1_raw_dmg = c1.damage * p1_reps
	var p2_def_val = c2.block_value + c2.dodge_value # Total defensive output
	var p2_mitigated = 0
	
	if p2_is_dodged:
		# P1 dodged P2's attack? No, wait. 
		# If P2 is dodged, P2's attack fails. 
		# If P1 is dodged, P1's attack fails.
		pass
		
	if p1_is_dodged:
		# P2 Dodged P1: 100% Negation
		p2_mitigated = p1_raw_dmg
	else:
		# P2 Blocks P1
		p2_mitigated = min(p1_raw_dmg, c2.block_value) # You can only block what exists
		
	var p1_net_dmg = max(0, p1_raw_dmg - p2_mitigated)
	if c1.guard_break and c2.block_value > 0:
		p1_net_dmg = p1_raw_dmg # Ignore block
		p2_mitigated = 0
		tags.append("P1_GuardBreak")

	# P2 Attacks -> P1 Defends
	var p2_raw_dmg = c2.damage * p2_reps
	var p1_def_val = c1.block_value + c1.dodge_value
	var p1_mitigated = 0
	
	if p2_is_dodged:
		p1_mitigated = p2_raw_dmg
	else:
		p1_mitigated = min(p2_raw_dmg, c1.block_value)
		
	var p2_net_dmg = max(0, p2_raw_dmg - p1_mitigated)
	if c2.guard_break and c1.block_value > 0:
		p2_net_dmg = p2_raw_dmg
		p1_mitigated = 0
		tags.append("P2_GuardBreak")

	# --- E. EFFICIENCY METRICS (Wasted Stats) ---
	# Did P1 use a Dodge 4 on a Cost 1 move? Wasted = 3.
	var p1_def_wasted = 0
	if c1.dodge_value > 0:
		if p2_is_dodged: p1_def_wasted = max(0, c1.dodge_value - p2_total_cost)
		else: p1_def_wasted = c1.dodge_value # Failed dodge = 100% wasted
	elif c1.block_value > 0:
		p1_def_wasted = max(0, c1.block_value - p2_raw_dmg)

	var p2_def_wasted = 0
	if c2.dodge_value > 0:
		if p1_is_dodged: p2_def_wasted = max(0, c2.dodge_value - p1_total_cost)
		else: p2_def_wasted = c2.dodge_value
	elif c2.block_value > 0:
		p2_def_wasted = max(0, c2.block_value - p1_raw_dmg)

	# --- F. RESOURCE DELTAS (The "Score") ---
	
	# HP Delta = (Heals) - (Damage Taken)
	var p1_hp_delta = c1.heal_value - p2_net_dmg
	var p2_hp_delta = c2.heal_value - p1_net_dmg
	
	# SP Delta = (Recover) - (Cost) - (Tiring Taken)
	# Note: Defence cards usually get +1 Recover in game logic
	var p1_rec = c1.recover_value + (1 if c1.type == ActionData.Type.DEFENCE else 0)
	var p2_rec = c2.recover_value + (1 if c2.type == ActionData.Type.DEFENCE else 0)
	
	var p1_sp_delta = p1_rec - p1_total_cost - c2.tiring
	var p2_sp_delta = p2_rec - p2_total_cost - c1.tiring
	
	# --- G. MOMENTUM ---
	# (Includes the Parry fix)
	var p1_push = c1.momentum_gain * p1_reps
	var p2_push = c2.momentum_gain * p2_reps
	
	if p2_parries: p1_push -= c1.momentum_gain
	if p1_parries: p2_push -= c2.momentum_gain
	
	if p1_is_dodged: p1_push = 0
	if p2_is_dodged: p2_push = 0
	
	var mom_shift = p1_push - p2_push
	
	# Check Reversal
	# If Mom moves towards P1 (Positive) but P2 used Reversal?
	# (Simplified vacuum check)
	if c1.reversal and mom_shift < 0: tags.append("P1_Reversal")
	if c2.reversal and mom_shift > 0: tags.append("P2_Reversal")

	# --- H. OUTPUT ---
	var row_data = [
		c1.display_name, c2.display_name, 
		"OFF" if c1.type == 0 else "DEF", "OFF" if c2.type == 0 else "DEF",
		priority_winner,
		p1_total_cost, p2_total_cost,
		p1_raw_dmg, p2_raw_dmg,
		p2_mitigated, p1_mitigated, # Note swap: P2 mitigated P1's damage
		p1_net_dmg, p2_net_dmg,     # P1 Net = Damage P1 DEALT (Wait, no. Net Dmg usually means Dmg TAKEN in logs, but here let's stick to Dmg DEALT by P1)
		# Actually, specifically for balance, "P1 Net Dmg" usually means "Damage P1 dealt to P2".
		# Let's keep that convention.
		
		c1.block_value + c1.dodge_value, c2.block_value + c2.dodge_value,
		p1_def_wasted, p2_def_wasted,
		p1_hp_delta, p2_hp_delta,
		p1_sp_delta, p2_sp_delta,
		mom_shift,
		";".join(tags)
	]
	
	# Convert all to string
	var str_row = []
	for item in row_data: str_row.append(str(item))
	return ",".join(str_row)

# (Keep _load_all_actions and _scan_dir the same as before)
func _load_all_actions() -> Array[ActionData]:
	var actions: Array[ActionData] = []
	var path = "res://Data/Actions/"
	actions.append_array(_scan_dir(path))
	var class_folders = ["Heavy", "Patient", "Quick", "Technical"]
	for folder in class_folders:
		actions.append_array(_scan_dir(path + "Class/" + folder + "/"))
	return actions

func _scan_dir(path) -> Array[ActionData]:
	var list: Array[ActionData] = []
	var dir = DirAccess.open(path)
	if dir:
		dir.list_dir_begin()
		var file = dir.get_next()
		while file != "":
			if file.ends_with(".tres") or file.ends_with(".res"):
				var res = load(path + file)
				if res is ActionData:
					list.append(res)
			file = dir.get_next()
	return list


========================================
FILE PATH: res://Scripts/BattleUI.gd
========================================
extends CanvasLayer

#region vars
signal human_selected_card(action_card, extra_data)
signal p1_mode_toggled(is_human)
signal p2_mode_toggled(is_human)

# --- REFERENCES ---
@onready var p1_hud = $P1_HUD 
@onready var p2_hud = $P2_HUD
@onready var momentum_slider = $MomentumSlider
@onready var momentum_label = $MomentumSlider/Label 
@onready var combat_log = $CombatLog

@onready var button_grid = %ButtonGrid
@onready var preview_card = %PreviewCard
@onready var tooltip_label = $MainLayout/PreviewAnchor/ToolTipLabel
@onready var btn_offence = %Offence        
@onready var btn_defence = %Defence      
@onready var equipment_grid = $EquipmentGrid

@onready var log_toggle = $LogToggle 

@onready var clash_layer = $ClashLayer
@onready var left_card_display = $ClashLayer/LeftCard
@onready var right_card_display = $ClashLayer/RightCard
@onready var background = $Background

@onready var env_button = $EnvButton
@onready var env_popup = $EnvPopup
@onready var env_title = $EnvPopup/VBoxContainer/EnvTitle
@onready var env_details = $EnvPopup/VBoxContainer/EnvDetails
@onready var close_env_button = $EnvPopup/VBoxContainer/CloseEnvButton
@onready var inspect_btn = $InspectButton
@onready var inspect_popup = $InspectPopup
@onready var inspect_grid = $InspectPopup/ScrollContainer/InspectGrid

@onready var p1_bark_label = $P1_Bark # Adjust path
@onready var p2_bark_label = $P2_Bark

var card_display_scene = preload("res://Scenes/CardDisplay.tscn")

# --- DATA ---
var card_button_scene = preload("res://Scenes/CardButton.tscn")
var floating_text_scene = preload("res://Scenes/FloatingText.tscn")
var compendium_scene = preload("res://Scenes/compendium.tscn")
var current_deck: Array[ActionData] = []
var current_tab = ActionData.Type.OFFENCE

var _prev_p1_stats = { "hp": 0, "sp": 0 }
var _prev_p2_stats = { "hp": 0, "sp": 0 }

# State Constraints
var current_sp_limit: int = 0 
var current_hp_limit: int = 0
var my_opportunity_val: int = 0
var my_opening_value: int = 0
var turn_cost_limit: int = 99 
var opener_restriction: bool = false
var super_allowed: bool = false 
var feint_mode: bool = false 

var skip_action: ActionData
var is_locked = false
var finisher_triggered: bool = false # PREVENTS DOUBLE TRIGGERS

# Toggle Buttons
var p1_toggle: CheckButton
var p2_toggle: CheckButton

# --- VISUALS (Passives & Juice) ---
var rage_toggle: CheckButton
var keep_up_toggle: CheckButton
var tech_dropdown: OptionButton

# DYNAMIC CAMERA VARIABLES
var shake_strength: float = 0.0
var shake_decay: float = 5.0
var zoom_strength: float = 0.0 
var zoom_decay: float = 5.0    
#endregion

func _ready():
	process_mode = Node.PROCESS_MODE_ALWAYS 
	
	if not btn_offence or not btn_defence:
		printerr("CRITICAL: Buttons missing in BattleUI")
		return
	
	# --- NEW: GENERATE SHADER FOR BACKGROUND ---
	# This allows us to desaturate the BG without needing a file
	var shader = Shader.new()
	shader.code = """
	shader_type canvas_item;
	uniform float saturation : hint_range(0.0, 1.0) = 1.0;
	void fragment() {
		vec4 tex_color = texture(TEXTURE, UV);
		float grey = dot(tex_color.rgb, vec3(0.299, 0.587, 0.114));
		vec3 final_color = mix(vec3(grey), tex_color.rgb, saturation);
		COLOR = vec4(final_color, tex_color.a);
	}
	"""
	var mat = ShaderMaterial.new()
	mat.shader = shader
	if background:
		background.material = mat
	# -------------------------------------------

	GameManager.wall_crush_occurred.connect(_on_wall_crush_ui)
	
	momentum_slider.max_value = GameManager.TOTAL_MOMENTUM_SLOTS
	momentum_slider.min_value = 1
	
	GameManager.combat_log_updated.emit("Location: " + GameManager.current_environment_name + " (" + str(GameManager.TOTAL_MOMENTUM_SLOTS) + " Slots)")
	
	if clash_layer: clash_layer.visible = false
	
	log_toggle.button_pressed = false
	combat_log.visible = false
	
	if log_toggle:
		log_toggle.toggled.connect(_on_log_toggled)
		combat_log.visible = log_toggle.button_pressed
	
	btn_offence.pressed.connect(func(): _switch_tab(ActionData.Type.OFFENCE))
	btn_defence.pressed.connect(func(): _switch_tab(ActionData.Type.DEFENCE))
	
	skip_action = ActionData.new()
	skip_action.display_name = "SKIP FEINT"
	skip_action.description = "Stop combining and use your original action."
	skip_action.cost = 0
	
	button_grid.visible = false
	preview_card.visible = false
	if tooltip_label: tooltip_label.visible = false
	
	GameManager.damage_dealt.connect(_on_damage_dealt)
	GameManager.healing_received.connect(_on_healing_received)
	GameManager.status_applied.connect(_on_status_applied)	
	GameManager.combat_log_updated.connect(_on_combat_log_updated)
	GameManager.clash_resolved.connect(_on_clash_resolved_log)
	
	_attach_sfx(btn_offence)
	_attach_sfx(btn_defence)
	_attach_sfx(log_toggle)
	
	var menu_btn = get_node_or_null("MenuButton")
	if menu_btn: _attach_sfx(menu_btn)
	
	if not GameManager.state_changed.is_connected(_on_game_state_changed):
		GameManager.state_changed.connect(_on_game_state_changed)
	
	await get_tree().process_frame
	_snapshot_stats()
	
	_create_debug_toggles()
	_create_passive_toggles()
	setup_toggles()
	
	if menu_btn:
		menu_btn.pressed.connect(_on_menu_pressed)

	$MomentumSlider/Label2.text = str(GameManager.momentum)

	if env_button and env_popup:
		env_button.pressed.connect(_on_env_button_pressed)
		close_env_button.pressed.connect(func(): env_popup.visible = false)
		_attach_sfx(env_button)
		_attach_sfx(close_env_button)
		env_details.bbcode_enabled = true
		env_details.fit_content = true
		env_button.text = "LOCATION: " + GameManager.current_environment_name.to_upper()
	
	if inspect_btn:
		inspect_btn.pressed.connect(_on_inspect_pressed)
		_attach_sfx(inspect_btn)
	
	_update_background()
	
# --- DYNAMIC CAMERA PROCESS ---
func _process(delta):
	# 1. Decay Values
	# FIX: Only decay if we are NOT in the middle of a Finisher Freeze
	var is_frozen = (finisher_triggered and get_tree().paused)
	
	if not is_frozen:
		if shake_strength > 0:
			shake_strength = lerpf(shake_strength, 0, shake_decay * delta)
			if shake_strength < 0.1: shake_strength = 0
			
		if zoom_strength > 0:
			zoom_strength = lerpf(zoom_strength, 0, zoom_decay * delta)
			if zoom_strength < 0.001: zoom_strength = 0

	# 2. Calculate Scale (Base 1.0 + Zoom Punch)
	var current_scale = 1.0 + zoom_strength
	scale = Vector2(current_scale, current_scale)
	
	# 3. Calculate Centering Offset
	var viewport_size = get_viewport().get_visible_rect().size
	var center = viewport_size / 2
	var center_offset = center - (center * current_scale)
	
	# 4. Calculate Shake Offset
	var shake_offset = Vector2.ZERO
	if shake_strength > 0:
		shake_offset = Vector2(
			randf_range(-shake_strength, shake_strength),
			randf_range(-shake_strength, shake_strength)
		)
	
	# 5. Apply Total Offset
	offset = center_offset + shake_offset

func apply_camera_impact(zoom_amount: float, shake_amount: float):
	zoom_strength = max(zoom_strength, zoom_amount)
	shake_strength = max(shake_strength, shake_amount)

# --- FINISHER SEQUENCE ---
func _play_finisher_sequence():
	if finisher_triggered: return
	finisher_triggered = true
	
	print(">>> FINISHER TRIGGERED <<<")
	
	# 1. FREEZE TIME (Longer than normal)
	HitStopManager.stop_frame(1.5)
	
	# 2. EXTREME ZOOM
	# We set it high. The _process loop above ensures it STAYS high while paused.
	zoom_strength = 0.45
	shake_strength = 0.0 # Clear shake to focus on the impact
	
	# 3. BACKGROUND DESATURATION (Using tween_method)
	if background and background.material:
		var tween = create_tween()
		tween.set_pause_mode(Tween.TWEEN_PAUSE_PROCESS) # Run while paused
		# Fade saturation from 1.0 to 0.0 over 0.1 seconds
		tween.tween_method(_set_bg_saturation, 1.0, 0.0, 0.1)

# ... (Rest of existing toggles code) ...

func _create_passive_toggles():
	var container = HBoxContainer.new()
	add_child(container)
	container.set_anchors_and_offsets_preset(Control.PRESET_CENTER_BOTTOM)
	container.position.y -= 200
	container.position.x -= 570
	rage_toggle = CheckButton.new()
	rage_toggle.text = "RAGE (Pay HP)"
	rage_toggle.visible = false
	rage_toggle.toggled.connect(func(_on): _refresh_grid())
	container.add_child(rage_toggle)
	
	keep_up_toggle = CheckButton.new()
	keep_up_toggle.text = "KEEP UP (Pay SP)"
	keep_up_toggle.visible = false
	container.add_child(keep_up_toggle)
	
	tech_dropdown = OptionButton.new()
	tech_dropdown.add_item("Tech: None")
	tech_dropdown.add_item("+Opener (1 SP)")
	tech_dropdown.add_item("+Tiring 1 (1 SP)")
	tech_dropdown.add_item("+Momentum 1 (1 SP)")
	tech_dropdown.selected = 0
	tech_dropdown.visible = false
	tech_dropdown.item_selected.connect(func(_idx): _refresh_grid())
	container.add_child(tech_dropdown)
	
func setup_passive_toggles(class_type: CharacterData.ClassType):
	rage_toggle.visible = (class_type == CharacterData.ClassType.HEAVY)
	keep_up_toggle.visible = (class_type == CharacterData.ClassType.PATIENT)
	tech_dropdown.visible = (class_type == CharacterData.ClassType.TECHNICAL)
	tech_dropdown.selected = 0 
	rage_toggle.button_pressed = false
	keep_up_toggle.button_pressed = false

func _create_debug_toggles():
	var container = HBoxContainer.new()
	add_child(container)
	container.set_anchors_and_offsets_preset(Control.PRESET_CENTER_TOP)
	container.position.y += 60 
	container.add_theme_constant_override("separation", 20)
	container.visible = false
	container.name = "DebugContainer" 
	
	var p1_is_human = true 
	var p2_is_human = false
	if not RunManager.is_arcade_mode and GameManager.p2_is_custom:
		p2_is_human = true
	
	p1_toggle = CheckButton.new()
	p1_toggle.text = "P1 Human"
	p1_toggle.toggled.connect(func(on): emit_signal("p1_mode_toggled", on))
	p1_toggle.button_pressed = p1_is_human 
	container.add_child(p1_toggle)
	
	p2_toggle = CheckButton.new()
	p2_toggle.text = "P2 Human"
	p2_toggle.toggled.connect(func(on): emit_signal("p2_mode_toggled", on))
	p2_toggle.button_pressed = p2_is_human
	container.add_child(p2_toggle)

func initialize_hud(p1_data: CharacterData, p2_data: CharacterData):
	p1_hud.setup(p1_data)
	p2_hud.setup(p2_data)
	p1_hud.configure_visuals(false) 
	p2_hud.configure_visuals(true)
	update_momentum(0)
	
	_populate_equipment(p1_data)

func update_all_visuals(p1: CharacterData, p2: CharacterData, momentum: int):
	p1_hud.update_stats(p1, GameManager.p1_opportunity_stat, GameManager.p1_opening_stat, p1.patient_buff_active)
	p2_hud.update_stats(p2, GameManager.p2_opportunity_stat, GameManager.p2_opening_stat, p2.patient_buff_active)
	
	update_momentum(momentum)
	$MomentumSlider/Label2.text = str(GameManager.momentum)

func update_momentum(val: int):
	var visual_val = val
	var text = "NEUTRAL: " + GameManager.current_environment_name
	if val == 0: 
		visual_val = float(GameManager.TOTAL_MOMENTUM_SLOTS) / 2.0 + 0.5
	elif val <= GameManager.MOMENTUM_P1_MAX: 
		text = "P1 MOMENTUM"
	else: 
		text = "P2 MOMENTUM"
		
	var tween = create_tween()
	tween.tween_property(momentum_slider, "value", visual_val, 0.4).set_trans(Tween.TRANS_CUBIC).set_ease(Tween.EASE_OUT)
	if momentum_label: momentum_label.text = text

func load_deck(deck: Array[ActionData]):
	current_deck = deck
	_refresh_grid()

func unlock_for_input(forced_tab, player_current_sp: int, player_current_hp: int, must_be_opener: bool = false, max_cost: int = 99, opening_val: int = 0, can_use_super: bool = false, opportunity_val: int = 0, is_feint_mode: bool = false):
	button_grid.visible = true 
	is_locked = false
	current_sp_limit = player_current_sp
	current_hp_limit = player_current_hp
	opener_restriction = must_be_opener
	turn_cost_limit = max_cost 
	my_opening_value = opening_val
	super_allowed = can_use_super 
	my_opportunity_val = opportunity_val 
	feint_mode = is_feint_mode 
	
	if forced_tab != null:
		_switch_tab(forced_tab)
		btn_offence.disabled = (forced_tab != ActionData.Type.OFFENCE)
		btn_defence.disabled = (forced_tab != ActionData.Type.DEFENCE)
		btn_offence.modulate = Color.WHITE if !btn_offence.disabled else Color(0.3, 0.3, 0.3)
		btn_defence.modulate = Color.WHITE if !btn_defence.disabled else Color(0.3, 0.3, 0.3)
	else:
		btn_offence.disabled = false
		btn_defence.disabled = false
		_switch_tab(current_tab)

func lock_ui():
	is_locked = true
	button_grid.visible = false 
	_on_card_exited() 

func _on_card_selected(card: ActionData):
	if is_locked: return
	var extra_data = {
		"rage": rage_toggle.button_pressed if rage_toggle.visible else false,
		"keep_up": keep_up_toggle.button_pressed if keep_up_toggle.visible else false,
		"technique": tech_dropdown.selected if tech_dropdown.visible else 0 
	}
	emit_signal("human_selected_card", card, extra_data)
	lock_ui() 

func _switch_tab(type):
	current_tab = type
	_refresh_grid()
	if !btn_offence.disabled: btn_offence.modulate = Color.WHITE if type == ActionData.Type.OFFENCE else Color(0.6, 0.6, 0.6)
	if !btn_defence.disabled: btn_defence.modulate = Color.WHITE if type == ActionData.Type.DEFENCE else Color(0.6, 0.6, 0.6)

func _refresh_grid():
	for child in button_grid.get_children():
		child.queue_free()
		
	for card in current_deck:
		if card == null: continue
		if card.type != current_tab: continue 
		
		var final_cost = _calculate_card_cost(card)
		var is_valid = _check_card_validity(card, final_cost)
		
		var btn = card_button_scene.instantiate()
		button_grid.add_child(btn)
		
		btn.setup(card)
		btn.update_cost_display(final_cost) 
		btn.set_available(is_valid)         
		
		btn.mouse_entered.connect(func(): AudioManager.play_sfx("ui_hover", 0.1))
		btn.pressed.connect(func(): AudioManager.play_sfx("ui_click"))
		
		btn.card_hovered.connect(_on_card_hovered)
		btn.card_exited.connect(_on_card_exited) 
		btn.card_selected.connect(_on_card_selected)
		
	if not feint_mode:
		var struggle = GameManager.get_struggle_action(current_tab)
		var s_btn = card_button_scene.instantiate()
		button_grid.add_child(s_btn)
		
		s_btn.setup(struggle)
		s_btn.update_cost_display(0)
		s_btn.set_available(true)
		s_btn.modulate = Color(0.9, 0.9, 0.9) 
		
		s_btn.mouse_entered.connect(func(): AudioManager.play_sfx("ui_hover", 0.1))
		s_btn.pressed.connect(func(): AudioManager.play_sfx("ui_click"))
		
		s_btn.card_hovered.connect(_on_card_hovered)
		s_btn.card_exited.connect(_on_card_exited)
		s_btn.card_selected.connect(_on_card_selected)
	
	if feint_mode:
		skip_action.type = current_tab 
		var skip_btn = card_button_scene.instantiate()
		button_grid.add_child(skip_btn)
		
		skip_btn.setup(skip_action)
		skip_btn.update_cost_display(0)
		skip_btn.set_available(true)
		skip_btn.modulate = Color(0.9, 0.9, 1.0) 
		
		skip_btn.mouse_entered.connect(func(): AudioManager.play_sfx("ui_hover", 0.1))
		skip_btn.pressed.connect(func(): AudioManager.play_sfx("ui_click"))
		
		skip_btn.card_hovered.connect(_on_card_hovered)
		skip_btn.card_exited.connect(_on_card_exited)
		skip_btn.card_selected.connect(_on_card_selected)

func _calculate_card_cost(card: ActionData) -> int:
	var tech_idx = tech_dropdown.selected if tech_dropdown.visible else 0
	var tech_cost = 1 if tech_idx > 0 else 0
	var base_cost = card.cost + tech_cost
	var effective_single_cost = max(0, base_cost - my_opportunity_val)
	var total_reps = max(1, card.repeat_count)
	return effective_single_cost * total_reps

func _check_card_validity(card: ActionData, final_cost: int) -> bool:
	var can_afford = false
	if rage_toggle.visible and rage_toggle.button_pressed:
		can_afford = (current_hp_limit > final_cost)
	else:
		can_afford = (final_cost <= current_sp_limit)
	
	if not can_afford: return false

	var tech_idx = tech_dropdown.selected if tech_dropdown.visible else 0
	if tech_idx == 1 and card.type == ActionData.Type.DEFENCE:
		return false

	var effective_is_opener = card.is_opener
	if tech_idx == 1 and card.type == ActionData.Type.OFFENCE:
		effective_is_opener = true
		
	if opener_restriction and card.type == ActionData.Type.OFFENCE and not effective_is_opener:
		return false

	if card.cost > turn_cost_limit: return false
	if card.counter_value > 0 and my_opening_value < card.counter_value: return false
	if card.is_super and not super_allowed: return false

	return true

func _on_card_hovered(card: ActionData):
	var effective_cost = max(0, card.cost - my_opportunity_val)
	preview_card.set_card_data(card, effective_cost)
	preview_card.visible = true
	_update_tooltip_text(card)

func _on_card_exited():
	preview_card.visible = false
	if tooltip_label: tooltip_label.visible = false

func _update_tooltip_text(card: ActionData):
	if not tooltip_label: return
	
	var active_keys = []
	if card.type == ActionData.Type.OFFENCE: active_keys.append("Offence")
	if card.type == ActionData.Type.DEFENCE: active_keys.append("Defence")
	if card.cost > 0: active_keys.append("Cost")
	if card.damage > 0: active_keys.append("Damage")
	if card.momentum_gain > 0: active_keys.append("Momentum")
	if card.block_value > 0: active_keys.append("Block")
	if card.dodge_value > 0: active_keys.append("Dodge")
	if card.heal_value > 0: active_keys.append("Heal")
	if card.recover_value > 0: active_keys.append("Recover")
	if card.fall_back_value > 0: active_keys.append("Fall Back")
	if card.counter_value > 0: active_keys.append("Counter")
	if card.tiring > 0: active_keys.append("Tiring")
	if card.is_opener: active_keys.append("Opener")
	if card.is_super: active_keys.append("Super")
	if card.guard_break: active_keys.append("Guard Break")
	if card.feint: active_keys.append("Feint")
	
	for s in card.statuses_to_apply:
		var s_name = s.get("name", "")
		if s_name != "":
			active_keys.append(s_name)

	if card.retaliate: active_keys.append("Retaliate")
	if card.reversal: active_keys.append("Reversal")
	if card.is_parry: active_keys.append("Parry")
	if card.sweep: active_keys.append("Sweep")
	if card.multi_limit > 0: active_keys.append("Multi")
	if card.repeat_count > 1: active_keys.append("Repeat")
	if card.create_opening > 0: active_keys.append("Create Opening")
	if card.opportunity > 0: active_keys.append("Opportunity")
	
	if active_keys.is_empty():
		tooltip_label.visible = false
		return
		
	var full_text = ""
	for k in active_keys:
		if k in GameManager.KEYWORD_DEFS:
			full_text += "[b]" + k + ":[/b] " + GameManager.KEYWORD_DEFS[k] + "\n"
			
	tooltip_label.text = full_text
	tooltip_label.visible = true
	
	tooltip_label.size.y = 0 
	var padding = 20
	var preview_bottom = preview_card.position.y + preview_card.size.y
	tooltip_label.position.y = preview_bottom - tooltip_label.size.y - padding
	tooltip_label.position.x = preview_card.position.x - tooltip_label.size.x - padding

func _get_clash_text_pos(target_id: int) -> Vector2:
	var hud = p1_hud if target_id == 1 else p2_hud
	var pos = hud.global_position + (hud.size / 2)
	var center_offset = 100 
	pos.y += 75
	if target_id == 1: pos.x += center_offset
	else: pos.x -= center_offset
	return pos

func _on_damage_dealt(target_id: int, amount: int, is_blocked: bool):
	var spawn_pos = _get_clash_text_pos(target_id)
	if is_blocked: 
		_spawn_text(spawn_pos, "BLOCKED", Color.GRAY)
		AudioManager.play_sfx("block", 0.1)
	else: 
		_spawn_text(spawn_pos, str(amount), Color.RED)
		if amount >= 5:
			AudioManager.play_sfx("hit_heavy", 0.1)
			apply_camera_impact(0.15, 20.0) 
		else:
			AudioManager.play_sfx("hit_light", 0.2) 
			apply_camera_impact(0.05, 5.0)  
			
		if target_id == 1: p1_hud.play_hit_animation()
		else: p2_hud.play_hit_animation()
	
	# React to heavy hits (>3 damage)
	if amount >= 3:
		var victim = GameManager.p1_data if target_id == 1 else GameManager.p2_data
		var line = DialogueManager.get_reaction(victim.class_type, "HURT_HEAVY")
		# High priority: Show this even if we barked recently
		_show_bark(target_id, line)
		
	# React to Death?
	# (Already covered by Low HP lines potentially, or add a specific check here)
	
	# --- NEW: CHECK FOR FINISHER ---
	# We check if the victim is dead, and trigger the cinematic
	var victim_data = GameManager.p1_data if target_id == 1 else GameManager.p2_data
	if victim_data.current_hp <= 0:
		_play_finisher_sequence()
	# --------------------------------

func _on_healing_received(target_id: int, amount: int):
	var spawn_pos = _get_clash_text_pos(target_id)
	_spawn_text(spawn_pos, "+" + str(amount), Color.GREEN)

func _on_status_applied(target_id: int, status: String):
	var spawn_pos = _get_clash_text_pos(target_id)
	spawn_pos.y -= 40 
	_spawn_text(spawn_pos, status, Color.YELLOW)

func _spawn_text(pos: Vector2, text: String, color: Color):
	var popup = floating_text_scene.instantiate()
	add_child(popup)
	popup.setup(text, color, pos)

func _on_combat_log_updated(text: String):
	if combat_log: combat_log.add_log(text)

func _on_clash_resolved_log(winner_id, p1_card, p2_card, _log_text):
	if combat_log:
		combat_log.add_clash_log(winner_id, p1_card, p2_card)
		
	apply_camera_impact(0.02, 0.0) 
		
	if p1_card.type == ActionData.Type.OFFENCE:
		p1_hud.play_attack_animation(Vector2(50, 0))
	if p2_card.type == ActionData.Type.OFFENCE:
		p2_hud.play_attack_animation(Vector2(-50, 0))
		
	AudioManager.play_sfx("clash", 0.1)
	
	# 25% chance to bark on win (don't spam every turn)
	if randf() < 0.25:
		var winner_data = GameManager.p1_data if winner_id == 1 else GameManager.p2_data
		var winner_card = p1_card if winner_id == 1 else p2_card
		
		var context = "WIN_OFFENCE"
		if winner_card.type == ActionData.Type.DEFENCE:
			context = "WIN_DEFENCE"
			
		var line = DialogueManager.get_reaction(winner_data.class_type, context)
		_show_bark(winner_id, line)
	
func _on_log_toggled(toggled_on: bool):
	combat_log.visible = toggled_on

func play_clash_animation(p1_card: ActionData, p2_card: ActionData):
	clash_layer.visible = true
	left_card_display.set_card_data(p1_card)
	right_card_display.set_card_data(p2_card)
	
	var card_size = Vector2(250, 350) 
	left_card_display.custom_minimum_size = card_size
	left_card_display.size = card_size
	right_card_display.custom_minimum_size = card_size
	right_card_display.size = card_size
	
	left_card_display.pivot_offset = card_size / 2
	right_card_display.pivot_offset = card_size / 2
	left_card_display.scale = Vector2(1.0, 1.0)
	right_card_display.scale = Vector2(1.0, 1.0)
	
	var center = get_viewport().get_visible_rect().size / 2
	left_card_display.position.x = -400
	right_card_display.position.x = get_viewport().get_visible_rect().size.x + 400
	left_card_display.position.y = center.y - (card_size.y / 2)
	right_card_display.position.y = center.y - (card_size.y / 2)
	
	var tween = create_tween()
	tween.set_parallel(true)
	tween.set_trans(Tween.TRANS_QUART)
	tween.set_ease(Tween.EASE_OUT)
	
	tween.tween_property(left_card_display, "position:x", center.x - card_size.x - 40, 0.4)
	tween.tween_property(right_card_display, "position:x", center.x + 20, 0.4)
	
	await tween.finished
	HitStopManager.stop_frame(0.15) 
	await get_tree().create_timer(1.2).timeout
	
	clash_layer.visible = false
	GameManager.clash_animation_finished.emit()

func _on_menu_pressed():
	var compendium = compendium_scene.instantiate()
	compendium.is_overlay = true
	add_child(compendium)

func setup_toggles(p1_override = null, p2_override = null):
	var container = HBoxContainer.new()
	add_child(container)
	container.set_anchors_and_offsets_preset(Control.PRESET_CENTER_TOP)
	container.position.y += 60 
	container.add_theme_constant_override("separation", 20)
	container.visible = false
	container.name = "DebugContainer"
	
	var p1_is_human = true 
	var p2_is_human = false
	
	if not RunManager.is_arcade_mode and GameManager.p2_is_custom:
		p2_is_human = true
	
	if p1_override != null: p1_is_human = p1_override
	if p2_override != null: p2_is_human = p2_override
	
	p1_toggle = CheckButton.new()
	p1_toggle.text = "P1 Human"
	p1_toggle.toggled.connect(func(on): emit_signal("p1_mode_toggled", on))
	p1_toggle.button_pressed = p1_is_human 
	container.add_child(p1_toggle)
	
	p2_toggle = CheckButton.new()
	p2_toggle.text = "P2 Human"
	p2_toggle.toggled.connect(func(on): emit_signal("p2_mode_toggled", on))
	p2_toggle.button_pressed = p2_is_human
	container.add_child(p2_toggle)

func _on_game_state_changed(new_state):
	if new_state == GameManager.State.POST_CLASH:
		_log_stat_changes()
		
		# Reset finisher state
		finisher_triggered = false
		
		# Restore Color smoothly
		if background and background.material:
			var tween = create_tween()
			tween.tween_method(_set_bg_saturation, 0.0, 1.0, 0.5)

func _log_stat_changes():
	if not combat_log or not GameManager.p1_data or not GameManager.p2_data: return
	
	var p1_cur = { "hp": GameManager.p1_data.current_hp, "sp": GameManager.p1_data.current_sp }
	var p2_cur = { "hp": GameManager.p2_data.current_hp, "sp": GameManager.p2_data.current_sp }
	
	if _prev_p1_stats.hp == 0 and _prev_p2_stats.hp == 0:
		_snapshot_stats()
		return
	
	var p1_diff = { "hp": p1_cur.hp - _prev_p1_stats.hp, "sp": p1_cur.sp - _prev_p1_stats.sp }
	var p2_diff = { "hp": p2_cur.hp - _prev_p2_stats.hp, "sp": p2_cur.sp - _prev_p2_stats.sp }
	
	combat_log.add_round_summary(p1_diff, p2_diff, GameManager.momentum)
	_snapshot_stats()

func _snapshot_stats():
	if GameManager.p1_data:
		_prev_p1_stats = { "hp": GameManager.p1_data.current_hp, "sp": GameManager.p1_data.current_sp }
	if GameManager.p2_data:
		_prev_p2_stats = { "hp": GameManager.p2_data.current_hp, "sp": GameManager.p2_data.current_sp }

func _attach_sfx(btn: BaseButton):
	if not btn: return
	btn.mouse_entered.connect(func(): AudioManager.play_sfx("ui_hover", 0.2))
	btn.pressed.connect(func(): AudioManager.play_sfx("ui_click"))

func _on_wall_crush_ui(target_id: int, _dmg: int):
	apply_camera_impact(0.05, 15.0) 
	var original_x = momentum_slider.position.x
	var tween = create_tween()
	var shake_dir = -10 if target_id == 1 else 10
	tween.tween_property(momentum_slider, "position:x", original_x + shake_dir, 0.05)
	tween.tween_property(momentum_slider, "position:x", original_x, 0.2).set_trans(Tween.TRANS_ELASTIC).set_ease(Tween.EASE_OUT)

func _on_env_button_pressed():
	env_popup.visible = not env_popup.visible
	if env_popup.visible:
		env_title.text = "ENVIRONMENT: " + GameManager.current_environment_name.to_upper()
		var details = "[b]Momentum Tracker:[/b] " + str(GameManager.TOTAL_MOMENTUM_SLOTS) + " Slots\n"
		env_details.text = details

func _populate_equipment(p1_data: CharacterData):
	if not equipment_grid: return
	for child in equipment_grid.get_children():
		child.queue_free()
	for item in p1_data.equipment:
		var icon = TextureRect.new()
		icon.expand_mode = TextureRect.EXPAND_IGNORE_SIZE
		icon.custom_minimum_size = Vector2(40, 40)
		icon.stretch_mode = TextureRect.STRETCH_KEEP_ASPECT_CENTERED
		if item.icon: icon.texture = item.icon
		else: icon.texture = preload("res://icon.svg") 
		var tip = item.display_name + "\n" + item.description + "\n"
		tip += "-------------------\n"
		if item.max_hp_bonus != 0: tip += "Max HP: " + ("+" if item.max_hp_bonus > 0 else "") + str(item.max_hp_bonus) + "\n"
		if item.max_sp_bonus != 0: tip += "Max SP: " + ("+" if item.max_sp_bonus > 0 else "") + str(item.max_sp_bonus) + "\n"
		if item.starting_sp_bonus != 0: tip += "Start SP: +" + str(item.starting_sp_bonus) + "\n"
		if item.wall_crush_damage_bonus != 0: tip += "Wall Crush Dmg: +" + str(item.wall_crush_damage_bonus)
		icon.tooltip_text = tip 
		equipment_grid.add_child(icon)

func _on_inspect_pressed():
	inspect_popup.visible = not inspect_popup.visible
	if inspect_popup.visible:
		inspect_btn.text = "CLOSE INSPECT"
		_populate_enemy_deck()
	else:
		inspect_btn.text = "INSPECT OPPONENT"

func _populate_enemy_deck():
	for child in inspect_grid.get_children():
		child.queue_free()
	var p2 = GameManager.p2_data
	if not p2: return
	for card in p2.deck:
		var card_disp = card_display_scene.instantiate()
		inspect_grid.add_child(card_disp)
		card_disp.set_card_data(card)
		card_disp.custom_minimum_size = Vector2(180, 250)
		card_disp.scale = Vector2(0.8, 0.8) 
		card_disp.mouse_entered.connect(func(): AudioManager.play_sfx("ui_hover", 0.1))

# Helper to safely tween shader params
func _set_bg_saturation(val: float):
	if background and background.material:
		background.material.set_shader_parameter("saturation", val)

func _update_background():
	var env_name = GameManager.current_environment_name
	if GameManager.environment_backgrounds.has(env_name):
		background.texture = GameManager.environment_backgrounds[env_name]
	else:
		print("Warning: No art found for '" + env_name + "'. Using default.")

func _show_bark(player_id: int, text: String):
	var lbl = p1_bark_label if player_id == 1 else p2_bark_label
	lbl.text = text
	
	# Simple Pop-in Animation
	lbl.modulate.a = 0
	lbl.scale = Vector2(0.5, 0.5)
	
	var tween = create_tween()
	tween.set_parallel(true)
	tween.tween_property(lbl, "modulate:a", 1.0, 0.2)
	tween.tween_property(lbl, "scale", Vector2(1.2, 1.2), 0.2).set_trans(Tween.TRANS_BACK)
	
	# Wait, then fade out
	tween.chain().tween_interval(1.5)
	tween.chain().tween_property(lbl, "modulate:a", 0.0, 0.3)


========================================
FILE PATH: res://Scripts/CardButton.gd
========================================
extends Button

# Signals for UI Interaction
signal card_hovered(action)
signal card_exited()
signal card_selected(action)

var my_action: ActionData
var original_z_index: int = 0

func _ready():
	# CRITICAL: Set pivot to center so it scales symmetrically
	pivot_offset = size / 2
	original_z_index = z_index

func setup(action: ActionData):
	my_action = action
	text = action.display_name 
	
	# Ensure the label exists before trying to access it
	if has_node("CostLabel"):
		$CostLabel.text = str(action.cost) + " SP"
	
	# Visual Theme
	if action.type == ActionData.Type.OFFENCE:
		add_theme_color_override("font_color", Color("#ff9999")) 
	else:
		add_theme_color_override("font_color", Color("#99ccff")) 

# Handles grey-out/disable logic
func set_available(is_affordable: bool):
	disabled = not is_affordable
	
	if is_affordable:
		modulate = Color(1, 1, 1, 1) # Normal opacity
		mouse_default_cursor_shape = Control.CURSOR_POINTING_HAND
	else:
		modulate = Color(0.5, 0.5, 0.5, 0.5) # Greyed out
		mouse_default_cursor_shape = Control.CURSOR_FORBIDDEN

func _pressed():
	if not disabled:
		# Small "press" squash animation
		var tween = create_tween()
		tween.tween_property(self, "scale", Vector2(0.95, 0.95), 0.05)
		tween.tween_property(self, "scale", Vector2(1.0, 1.0), 0.05)
		
		emit_signal("card_selected", my_action)

func _on_mouse_entered():
	if disabled: return
	
	emit_signal("card_hovered", my_action)
	
	# 1. Bring to front so it overlaps neighbors
	z_index = 10 
	
	# 2. Pop Animation (Scale Up + Slight Tilt)
	var tween = create_tween()
	tween.set_parallel(true)
	tween.set_trans(Tween.TRANS_BACK).set_ease(Tween.EASE_OUT)
	
	# Scale up to 110%
	tween.tween_property(self, "scale", Vector2(1.1, 1.1), 0.15)
	
	# Random slight tilt (-2 to 2 degrees) for organic feel
	var random_tilt = randf_range(-2.0, 2.0)
	tween.tween_property(self, "rotation_degrees", random_tilt, 0.15)

func _on_mouse_exited():
	emit_signal("card_exited")
	
	# 1. Reset Layer
	z_index = original_z_index
	
	# 2. Reset Animation
	var tween = create_tween()
	tween.set_parallel(true)
	tween.set_trans(Tween.TRANS_CUBIC).set_ease(Tween.EASE_OUT)
	
	tween.tween_property(self, "scale", Vector2(1.0, 1.0), 0.1)
	tween.tween_property(self, "rotation_degrees", 0.0, 0.1)

# Dynamically updates cost text
func update_cost_display(new_cost: int):
	if not has_node("CostLabel"): return
	
	$CostLabel.text = str(new_cost) + " SP"
	
	if new_cost < my_action.cost:
		$CostLabel.modulate = Color(0.5, 1.0, 0.5) # Green text for discount
	else:
		$CostLabel.modulate = Color(1, 1, 1)


========================================
FILE PATH: res://Scripts/card_display.gd
========================================
extends Control

# UI References
@onready var background = $Background
@onready var cost_label = $VBoxContainer/Header/CostLabel
@onready var name_label = $VBoxContainer/Header/NameLabel
@onready var art_rect = $VBoxContainer/Art
@onready var stat_label = $VBoxContainer/StatsRow/StatLabel
@onready var desc_label = $VBoxContainer/Description

# Colors
const OFFENCE_COLOR = Color("#d14d4d") # Red
const DEFENCE_COLOR = Color("#4d8ad1") # Blue

func set_card_data(action: ActionData, override_cost: int = -1):
	# 1. Set Basic Text
	name_label.text = action.display_name
	
	# Determine Cost Display
	var final_cost = action.cost
	if override_cost != -1:
		final_cost = override_cost
		
	cost_label.text = str(final_cost) + " SP"
	desc_label.text = action.description
	
	if final_cost == 0 and override_cost == -1:
		cost_label.text = "" # Hide for classes
	else:
		cost_label.text = str(final_cost) + " SP"
	
	# 2. Set Art
	if action.icon:
		art_rect.texture = action.icon
	
	# 3. Set Color based on Type
	var bg_style = StyleBoxFlat.new()
	if action.type == ActionData.Type.OFFENCE:
		bg_style.bg_color = OFFENCE_COLOR
	else:
		bg_style.bg_color = DEFENCE_COLOR
	
	bg_style.set_corner_radius_all(10)
	background.add_theme_stylebox_override("panel", bg_style)
	
	# 4. Compile Stats String
	var stats_text = ""
	
	if action.damage > 0: stats_text += str(action.damage) + " DMG  "
	if action.block_value > 0: stats_text += str(action.block_value) + " BLK  "
	if action.dodge_value > 0: stats_text += str(action.dodge_value) + " DDG  "
	if action.heal_value > 0: stats_text += str(action.heal_value) + " HEAL "
		
	# Recover Logic (Visuals matching Game Logic)
	var final_rec = action.recover_value
	if action.type == ActionData.Type.DEFENCE:
		final_rec += 1
	if final_rec > 0: stats_text += str(final_rec) + " REC "
	
	# Boolean Tags
	if action.tiring > 0: stats_text += str(action.tiring) + " TIRE "
	if action.retaliate: stats_text += "RETAL "
	if action.feint: stats_text += "FEINT "
	
	# NEW: GENERIC STATUS TEXT
	for effect in action.statuses_to_apply:
		var s_name = effect.get("name", "???").to_upper()
		var s_val = effect.get("amount", 1)
		var is_self = effect.get("self", false)
		
		var prefix = "SELF " if is_self else ""
		var val_str = str(s_val) + " " if s_val > 1 else ""
		
		stats_text += prefix + val_str + s_name + " "
		
	stat_label.text = stats_text


========================================
FILE PATH: res://Scripts/card_displayTEST.gd
========================================
extends "res://Scripts/card_display.gd"

# Drag one of your Action Resources here in the Inspector
@export var test_action: ActionData 

func _ready():
	if test_action:
		set_card_data(test_action)


========================================
FILE PATH: res://Scripts/CarouselHub.gd
========================================
extends Control

# --- CONFIGURATION ---
var slides: Array = []
var current_index: int = 0
var is_transitioning: bool = false

# --- NODES ---
@onready var bg_current = $Background
@onready var bg_fader = $BackgroundFader
@onready var content_container = $ContentContainer
@onready var title_label = $UI_Layer/TitleLabel
@onready var btn_left = $UI_Layer/LeftArrow
@onready var btn_right = $UI_Layer/RightArrow
@onready var btn_back = $UI_Layer/BackButton

func _ready():
	# 1. DEFINE YOUR SLIDES HERE
	# Easy to add more later! Just append a new dictionary.
	slides = [
		{
			"title": "THE CIRCUIT (Story)",
			"scene_path": "res://Scenes/MenuArcade.tscn",
			"bg_path": "res://Art/Background/LockerRoom.png" # You need this art
		},
		{
			"title": "QUICK CLASH (PvP / PvE)",
			"scene_path": "res://Scenes/MenuQuick.tscn",
			"bg_path": "res://Art/Background/Street.png"
		},
		{
			"title": "GAME SETTINGS",
			"scene_path": "res://Scenes/MenuSettings.tscn",
			"bg_path": "res://Art/Background/Dojo.png"
		},
		{
			"title": "COMPENDIUM",
			"scene_path": "res://Scenes/compendium.tscn", # Reusing your existing scene!
			"bg_path": "res://Art/Background/Library.png"
		}
	]
	
	# 2. Setup Buttons
	btn_left.pressed.connect(func(): _change_slide(-1))
	btn_right.pressed.connect(func(): _change_slide(1))
	btn_back.pressed.connect(_on_back_pressed)
	
	# 3. Load Initial Slide (Arcade)
	_load_slide_content(0)
	_snap_background(0)

func _change_slide(direction: int):
	if is_transitioning: return
	is_transitioning = true
	AudioManager.play_sfx("ui_hover", 0.5) # Whoosh sound
	
	# 1. Calculate new index (Looping)
	var _old_index = current_index
	current_index += direction
	
	if current_index >= slides.size(): current_index = 0
	elif current_index < 0: current_index = slides.size() - 1
	
	# 2. VISUAL TRANSITION
	var slide_data = slides[current_index]
	title_label.text = slide_data.title
	
# A. Crossfade Background
	var new_bg = load(slide_data.bg_path)
	
	if new_bg:
		bg_fader.texture = new_bg
		bg_fader.modulate.a = 0.0
		bg_fader.visible = true # <--- FORCE VISIBILITY ON
		
		# Create the tween
		var t_bg = create_tween()
		t_bg.tween_property(bg_fader, "modulate:a", 1.0, 0.4)
		await t_bg.finished
		
		# Swap and reset
		bg_current.texture = new_bg
		bg_fader.modulate.a = 0.0
		# bg_fader.visible = false # Optional: Hide it again if you want
	else:
		print("ERROR: Could not load background at path: ", slide_data.bg_path)
	# B. Slide Content (The "Carousel" movement)
	# We instance the new scene OFF SCREEN, slide it in, then delete the old one.
	
	var old_content = content_container.get_child(0) if content_container.get_child_count() > 0 else null
	var new_scene = load(slide_data.scene_path).instantiate()
	
	# Determine direction
	var screen_width = get_viewport_rect().size.x
	var enter_pos = Vector2(screen_width, 0) if direction > 0 else Vector2(-screen_width, 0)
	var exit_pos = Vector2(-screen_width, 0) if direction > 0 else Vector2(screen_width, 0)
	
	# Setup New Content
	new_scene.position = enter_pos
	content_container.add_child(new_scene)
	
	# Animate
	var t_slide = create_tween().set_parallel(true).set_trans(Tween.TRANS_CUBIC).set_ease(Tween.EASE_OUT)
	
	t_slide.tween_property(new_scene, "position", Vector2.ZERO, 0.4)
	if old_content:
		t_slide.tween_property(old_content, "position", exit_pos, 0.4)
	
	await t_slide.finished
	
	if old_content: old_content.queue_free()
	is_transitioning = false

# Used for the very first load (instant, no animation)
func _load_slide_content(idx: int):
	var data = slides[idx]
	title_label.text = data.title
	
	for child in content_container.get_children():
		child.queue_free()
		
	var scene = load(data.scene_path).instantiate()
	content_container.add_child(scene)

func _snap_background(idx: int):
	var tex = load(slides[idx].bg_path)
	if tex: bg_current.texture = tex

func _on_back_pressed():
	SceneLoader.change_scene("res://Scenes/MainMenu.tscn")


========================================
FILE PATH: res://Scripts/CharacterSelect.gd
========================================
extends Control

@onready var p1_option = $HBoxContainer/P1_Column/ClassOption
@onready var p1_info = $HBoxContainer/P1_Column/InfoLabel
# NEW: Reference the texture rects you just created
@onready var p1_portrait = $HBoxContainer/P1_Column/P1_Portrait 

@onready var p2_option = $HBoxContainer/P2_Column/ClassOption
@onready var p2_info = $HBoxContainer/P2_Column/InfoLabel
@onready var p2_custom_check = $HBoxContainer/P2_Column/P2CustomCheck
# NEW: Reference the texture rects you just created
@onready var p2_portrait = $HBoxContainer/P2_Column/P2_Portrait

# New Buttons
@onready var btn_quick = $HBoxContainer/Center_Column/QuickFightButton
@onready var btn_custom = $HBoxContainer/Center_Column/CustomDeckButton
@onready var btn_back = $HBoxContainer/Center_Column/BackButton
@onready var difficulty_option = $HBoxContainer/Center_Column/DifficultyOption
@onready var p2_mode_button = $HBoxContainer/P2_Column/P2ModeButton
@onready var arcade_button = $HBoxContainer/Center_Column/ArcadeButton

@onready var run_settings_popup = $RunSettingsPopup
@onready var class_confirm_label = $RunSettingsPopup/Panel/VBoxContainer/ClassConfirmLabel
@onready var maintain_hp_toggle = $RunSettingsPopup/Panel/VBoxContainer/MaintainHPToggle
@onready var btn_confirm_run = $RunSettingsPopup/Panel/VBoxContainer/HBoxContainer/ConfirmRunButton
@onready var btn_cancel_run = $RunSettingsPopup/Panel/VBoxContainer/HBoxContainer/CancelRunButton


var compendium_scene = preload("res://Scenes/compendium.tscn")
var classes = ["Heavy", "Patient", "Quick", "Technical"]
var base_classes = ["Heavy", "Patient", "Quick", "Technical"]
var presets: Array[PresetCharacter] = []

func _ready():
	_load_presets()
	_setup_options(p1_option)
	_setup_options(p2_option)
	
	_setup_difficulty()
	
	var all_buttons = [
		btn_quick, btn_custom, btn_back, 
		p2_mode_button, find_child("HelpButton"), arcade_button
	]
	
	for btn in all_buttons:
		if btn: _attach_sfx(btn)
	
	_attach_sfx(p1_option)
	_attach_sfx(p2_option)
	_attach_sfx(difficulty_option)
	
	p1_option.item_selected.connect(func(_i): AudioManager.play_sfx("ui_click"))
	p2_option.item_selected.connect(func(_i): AudioManager.play_sfx("ui_click"))
	difficulty_option.item_selected.connect(func(_i): AudioManager.play_sfx("ui_click"))
	
	# Default selections
	p1_option.selected = 0
	p2_option.selected = 1
	_update_info()
	
	p1_option.item_selected.connect(func(_idx): _update_info())
	p2_option.item_selected.connect(func(_idx): _update_info())
	
	btn_quick.pressed.connect(_on_quick_fight_pressed)
	btn_custom.pressed.connect(_on_custom_deck_pressed)
	btn_back.pressed.connect(func(): SceneLoader.change_scene("res://Scenes/MainMenu.tscn"))
	
	if GameManager.p2_is_custom == null:
		GameManager.p2_is_custom = false
	
	_update_p2_mode_visuals()
	p2_mode_button.pressed.connect(_on_p2_mode_pressed)
	
	var btn_help = find_child("HelpButton") 
	if btn_help:
		btn_help.pressed.connect(_on_help_pressed)
	
	# NEW: Ensure P2 Portrait is flipped to look at P1 (Symmetry!)
	if p2_portrait:
		p2_portrait.flip_h = true
		
	btn_cancel_run.pressed.connect(func(): run_settings_popup.visible = false)
	btn_confirm_run.pressed.connect(_on_final_arcade_confirm)
	_attach_sfx(btn_cancel_run)
	_attach_sfx(btn_confirm_run)

func _load_presets():
	presets.clear()
	var path = "res://Data/Presets/"
	var dir = DirAccess.open(path)
	if dir:
		dir.list_dir_begin()
		var file_name = dir.get_next()
		while file_name != "":
			if dir.current_is_dir():
				file_name = dir.get_next()
				continue
				
			var load_path = path + file_name
			if file_name.ends_with(".remap"):
				load_path = load_path.trim_suffix(".remap")
				
			if load_path.ends_with(".tres") or load_path.ends_with(".res"):
				var res = load(load_path)
				if res is PresetCharacter:
					presets.append(res)
			
			file_name = dir.get_next()
		dir.list_dir_end()

func _setup_options(opt: OptionButton):
	opt.clear()
	for c in classes:
		opt.add_item(c)
	
	if presets.size() > 0:
		opt.add_separator("Presets")
		
	for p in presets:
		opt.add_item(p.character_name + " (" + ClassFactory.class_enum_to_string(p.class_type) + ")")

func _get_character_data_from_selection(index: int, player_name: String) -> CharacterData:
	if index < base_classes.size():
		var type = index as CharacterData.ClassType
		return ClassFactory.create_character(type, player_name)
	
	var preset_idx = index - base_classes.size() - 1 
	if preset_idx >= 0 and preset_idx < presets.size():
		var p = presets[preset_idx]
		var char_data = ClassFactory.create_from_preset(p)
		char_data.character_name = p.character_name
		return char_data
		
	return ClassFactory.create_character(0 as CharacterData.ClassType, "ErrorBot")

func _update_info():
	# Pass the portrait nodes to the display function
	_display_stats(p1_option.selected, p1_info, p1_portrait)
	_display_stats(p2_option.selected, p2_info, p2_portrait)

# UPDATED FUNCTION: Now accepts 'portrait_rect'
func _display_stats(idx: int, label: RichTextLabel, portrait_rect: TextureRect):
	var temp = _get_character_data_from_selection(idx, "Preview")
	
	# 1. Update Text
	var txt = "[b]" + temp.character_name + "[/b] (" + ClassFactory.class_enum_to_string(temp.class_type) + ")\n"
	txt += "[b]HP:[/b] " + str(temp.max_hp) + "\n"
	txt += "[b]SP:[/b] " + str(temp.max_sp) + "\n"
	txt += "[b]Speed:[/b] " + str(temp.speed) + "\n\n"
	
	if idx >= base_classes.size():
		txt += "[u]Custom Skills:[/u]\n"
		for card in temp.deck:
			if not card.display_name.begins_with("Basic"):
				txt += "- " + card.display_name + "\n"
	
	txt += "\n[color=yellow]" + temp.passive_desc + "[/color]"
	label.text = txt
	
	# 2. Update Portrait
	if portrait_rect:
		if temp.portrait:
			portrait_rect.texture = temp.portrait
			portrait_rect.modulate = Color.WHITE
		else:
			portrait_rect.texture = null # Clear if missing

func _on_quick_fight_pressed():
	# --- NEW: RANDOMIZE ENVIRONMENT FOR QUICK MATCH ---
	var envs = ["Ring", "Dojo", "Street"]
	GameManager.apply_environment_rules(envs.pick_random())
	# --------------------------------------------------
	
	var p1 = _get_character_data_from_selection(p1_option.selected, "Player 1")
	var p2 = _get_character_data_from_selection(p2_option.selected, "Player 2")
	GameManager.next_match_p1_data = p1
	GameManager.next_match_p2_data = p2
	SceneLoader.change_scene("res://Scenes/MainScene.tscn")

func _on_custom_deck_pressed():
	# 1. P1 SETUP
	var p1_sel = p1_option.selected
	if p1_sel < base_classes.size():
		GameManager.temp_p1_class_selection = p1_sel
		GameManager.temp_p1_name = "Player 1"
		GameManager.temp_p1_preset = null
	else:
		var preset_idx = p1_sel - base_classes.size() - 1
		if preset_idx >= 0:
			var p = presets[preset_idx]
			GameManager.temp_p1_class_selection = p.class_type
			GameManager.temp_p1_name = p.character_name
			GameManager.temp_p1_preset = p

	# 2. P2 SETUP
	var p2_sel = p2_option.selected
	if p2_sel < base_classes.size():
		GameManager.temp_p2_class_selection = p2_sel
		GameManager.temp_p2_name = "Player 2"
		GameManager.temp_p2_preset = null
	else:
		var preset_idx = p2_sel - base_classes.size() - 1
		if preset_idx >= 0:
			var p = presets[preset_idx]
			GameManager.temp_p2_class_selection = p.class_type
			GameManager.temp_p2_name = p.character_name
			GameManager.temp_p2_preset = p

	GameManager.editing_player_index = 1 
	
	if GameManager.p2_is_custom:
		GameManager.next_match_p2_data = null 
	else:
		var p2 = _get_character_data_from_selection(p2_sel, "Player 2")
		GameManager.next_match_p2_data = p2
	
	SceneLoader.change_scene("res://Scenes/ActionTree.tscn")

func _setup_difficulty():
	difficulty_option.clear()
	difficulty_option.add_item("Very Easy")
	difficulty_option.add_item("Easy")
	difficulty_option.add_item("Medium")
	difficulty_option.add_item("Hard")
	difficulty_option.selected = 2
	GameManager.ai_difficulty = GameManager.Difficulty.MEDIUM
	difficulty_option.item_selected.connect(_on_difficulty_changed)

func _on_difficulty_changed(index: int):
	GameManager.ai_difficulty = index as GameManager.Difficulty

func _on_start_arcade_pressed():
	var selected_idx = p1_option.selected
	var class_named = "Unknown"
	
	# Get Name for the confirmation text
	if selected_idx < base_classes.size():
		class_named = ClassFactory.class_enum_to_string(selected_idx as CharacterData.ClassType)
	else:
		var preset_idx = selected_idx - base_classes.size() - 1
		class_named = presets[preset_idx].character_name

	# Update UI
	class_confirm_label.text = "Start Arcade Run with: " + class_named + "?"
	maintain_hp_toggle.button_pressed = false # Reset toggle by default
	run_settings_popup.visible = true

func _on_help_pressed():
	var compendium = compendium_scene.instantiate()
	compendium.is_overlay = true
	compendium.initial_tab_index = 4 
	add_child(compendium)

func _on_p2_mode_pressed():
	GameManager.p2_is_custom = !GameManager.p2_is_custom
	_update_p2_mode_visuals()

func _update_p2_mode_visuals():
	if GameManager.p2_is_custom:
		p2_mode_button.text = "OPPONENT: PLAYER 2"
		p2_mode_button.modulate = Color(0.2, 1.0, 0.2) 
	else:
		p2_mode_button.text = "OPPONENT: CPU BOT"
		p2_mode_button.modulate = Color(0.8, 0.8, 0.8) 
		
	var p2_controls = get_node_or_null("P2Container") # Might be different in your scene
	if p2_controls:
		p2_controls.modulate.a = 1.0 if GameManager.p2_is_custom else 0.7

func _attach_sfx(node: Control):
	if not node: return
	# Most buttons use 'mouse_entered' and 'pressed'
	if node.has_signal("mouse_entered"):
		node.mouse_entered.connect(func(): AudioManager.play_sfx("ui_hover", 0.2))
	if node.has_signal("pressed"):
		node.pressed.connect(func(): AudioManager.play_sfx("ui_click"))

func _on_final_arcade_confirm():
	# 1. Save Modifiers to RunManager
	RunManager.maintain_hp_enabled = maintain_hp_toggle.button_pressed
	
	# 2. Start the Run (Existing logic)
	var selected_idx = p1_option.selected
	if selected_idx < base_classes.size():
		var class_enum = selected_idx as CharacterData.ClassType
		RunManager.start_run(class_enum)
	else:
		var preset_idx = selected_idx - base_classes.size() - 1
		if preset_idx >= 0 and preset_idx < presets.size():
			var preset = presets[preset_idx]
			RunManager.start_run_from_preset(preset)


========================================
FILE PATH: res://Scripts/ClassFactory.gd
========================================
extends Node

# Map Enum -> Resource Path
var class_registry = {
	CharacterData.ClassType.HEAVY: preload("res://Data/Classes/HeavyClass.tres"),
	CharacterData.ClassType.PATIENT: preload("res://Data/Classes/PatientClass.tres"),
	CharacterData.ClassType.QUICK: preload("res://Data/Classes/QuickClass.tres"),
	CharacterData.ClassType.TECHNICAL: preload("res://Data/Classes/TechnicalClass.tres")
}
# --- SHARED DATA: THE SKILL TREE MAP ---
# (Moved here so both the UI and the Enemy Generator can read it)
const TREE_CONNECTIONS = {
	1:[12,5], 2:[6,7], 3:[8,15], 4:[11,12], 5:[1,6], 6:[2,5,13,73], 7:[2,14,8,73], 8:[7,3],
	9:[15,16], 10:[11,19], 11:[4,10,20], 12:[4,1,13,20], 13:[12,6,21], 14:[7,15,21],
	15:[3,14,9,22], 16:[9,22,17], 17:[16,23], 18:[19,25], 19:[10,18,20,28], 20:[19,11,12,29],
	21:[13,14,29,31,30], 22:[15,16,23,31], 23:[22,17,24,32], 24:[23,26], 25:[18,27], 26:[24,33],
	27:[34,28,25,74], 28:[27,19,35], 29:[20,21,35], 30:[21], 31:[21,22,38], 32:[23,38,33],
	33:[32,26,39,75], 34:[27,40], 35:[28,41,29,42,36], 36:[35], 37:[38], 38:[31,32,44,45,37],
	39:[33,46], 40:[34,41,47,74], 41:[40,50,35], 42:[35,51,52], 43:[52], 44:[52,38,53],
	45:[38,46,54], 46:[45,48,75], 47:[40,49], 48:[46,55], 49:[47,50], 50:[49,41,51,56],
	51:[50,42,58,57], 52:[42,43,44,59,60], 53:[44,54,61,62], 54:[53,45,55,63], 55:[48,54],
	56:[50,57], 57:[56,51,64], 58:[51,64,59,70], 59:[52,66,58], 60:[52,67,61], 61:[53,72,69],
	62:[53,63,69], 63:[54,62], 64:[57,58], 65:[70,66], 66:[59,65,71,76], 67:[68,60,71,76],
	68:[67,72], 69:[61,62], 70:[58,65], 71:[66,67], 72:[68,61], 73:[2,6,7], 74:[34,27,40], 75:[39,33,46], 76:[71,66,67]
}

# Also need the ID-to-Name mapping for the generator to find files
const ID_TO_NAME_MAP = {
	1:"Toppling Kick", 2:"Pummel", 3:"One Two", 4:"Evading Dance", 5:"Slip Behind",
	6:"Adept Dodge", 7:"Adept Light", 8:"Hundred Hand Slap", 9:"Precise Strike", 10:"Breakout",
	11:"Read Offence", 12:"Quick Dodge", 13:"Master Dodge", 14:"Master Light", 15:"Flying Kick",
	16:"Vital Strike", 17:"Unassailable Stance", 18:"Strike Back", 19:"Leg Sweep", 20:"Catch",
	21:"Drop Prone", 22:"Perfect Strike", 23:"Step Up", 24:"Go with the Flow", 25:"Prime",
	26:"Inner Peace", 27:"Adept Reversal", 28:"Master Reversal", 29:"Untouchable Dodge",
	30:"Ultimate Barrage", 31:"Advancing Parry", 32:"Master Positioning", 33:"Adept Positioning",
	34:"Grab", 35:"Wind Up", 36:"Vital Point Assault", 37:"Overwhelming Aura", 38:"Parry FollowUp",
	39:"Adjust Stance", 40:"Adept Tech", 41:"Master Tech", 42:"Crushing Block", 43:"Final Strike",
	44:"Redirect", 45:"Master Parry", 46:"Adept Parry", 47:"Throw", 48:"Resounding Parry",
	49:"Push", 50:"Twist Arm", 51:"Suplex", 52:"Perfect Block", 53:"Active Block",
	54:"Retreating Defence", 55:"Resounding Counter", 56:"Read Defence", 57:"Headbutt", 58:"Lariat",
	59:"Master Heavy", 60:"Master Block", 61:"Draining Defence", 62:"Slapping Parry", 63:"Tiring Parry",
	64:"Roundhouse Kick", 65:"Uppercut", 66:"Adept Heavy", 67:"Adept Block", 68:"Push Kick",
	69:"Drop Punch", 70:"Knee Crush", 71:"Drop Kick", 72:"Immovable Stance",
	73:"Quick", 74:"Technical", 75:"Patient", 76:"Heavy"
}

const RANK_TITLES = [
	"Foolish",      # Level 1
	"Weak",         # Level 2
	"Clumsy",       # Level 3
	"Novice",       # Level 4
	"Beginner",     # Level 5
	"Rookie",       # Level 6
	"Apprentice",   # Level 7
	"Capable",      # Level 8
	"Competent",    # Level 9
	"Adept",        # Level 10
	"Seasoned",     # Level 11
	"Expert",       # Level 12
	"Veteran",      # Level 13
	"Elite",        # Level 14
	"Master",       # Level 15
	"Grandmaster",  # Level 16
	"Legendary",    # Level 17
	"Mythic",       # Level 18
	"Transcendent", # Level 19
	"Godly"         # Level 20+
]

var art_heavy = preload("res://Art/Portraits/Heavy.png") 
var art_patient = preload("res://Art/Portraits/Patient.png")
var art_quick = preload("res://Art/Portraits/Quick.png")
var art_technical = preload("res://Art/Portraits/Technical.png")

const HAND_LIMIT = 8

# --- NEW: ENEMY GENERATOR ---
func create_random_enemy(level: int, _difficulty: GameManager.Difficulty) -> CharacterData:
	# 1. Pick a Random Class
	var types = [
		CharacterData.ClassType.HEAVY, 
		CharacterData.ClassType.QUICK, 
		CharacterData.ClassType.TECHNICAL, 
		CharacterData.ClassType.PATIENT
	]
	var selected_class = types.pick_random()
	
	# 2. Create the Base Character (Starter Library)
	# Note: This assumes create_character() correctly populates unlocked_actions
	var bot_data = create_character(selected_class, "Lv." + str(level) + " Bot")
	
	# --- ASSIGN RANDOM PERSONALITY ---
	var personalities = CharacterData.AIArchetype.values()
	bot_data.ai_archetype = personalities.pick_random()
	
	# A. Get Rank Title based on Level
	var title_index = clampi(level - 1, 0, RANK_TITLES.size() - 1)
	var rank_title = RANK_TITLES[title_index]
	
	# Flavor: Rename the bot based on its brain
	var prefix = ""
	match bot_data.ai_archetype:
		CharacterData.AIArchetype.AGGRESSIVE: prefix = "Furious "
		CharacterData.AIArchetype.DEFENSIVE: prefix = "Guarded "
		CharacterData.AIArchetype.TRICKSTER: prefix = "Tricky "
		CharacterData.AIArchetype.BALANCED: prefix = "Steady "
	
	bot_data.character_name = rank_title + " " + prefix + class_enum_to_string(selected_class)
	
	# 3. Calculate how many extra cards they get (Library expansion)
	var cards_to_draft = level + 1
	
	# 4. "Draft" cards legally by walking the tree
	var owned_ids = []
	var unlockable_options = []
	
	# Identify the starting Root Node for this class
	var root_id = 0
	match selected_class:
		CharacterData.ClassType.QUICK: root_id = 73
		CharacterData.ClassType.TECHNICAL: root_id = 74
		CharacterData.ClassType.PATIENT: root_id = 75
		CharacterData.ClassType.HEAVY: root_id = 76
	
	# Initialize the 'shop' with the root's neighbors
	owned_ids.append(root_id)
	if root_id in TREE_CONNECTIONS:
		for neighbor in TREE_CONNECTIONS[root_id]:
			unlockable_options.append(neighbor)
			
	# Draft Loop
	for i in range(cards_to_draft):
		if unlockable_options.is_empty():
			break 
			
		# Pick a random valid card
		var picked_id = unlockable_options.pick_random()
		
		# "Buy" it -> Add to LIBRARY (unlocked_actions), NOT Deck
		var card_name = ID_TO_NAME_MAP.get(picked_id)
		if card_name:
			var new_card = find_action_resource(card_name)
			# Ensure we don't add duplicates to the library
			if new_card and not _has_card(bot_data.unlocked_actions, new_card):
				bot_data.unlocked_actions.append(new_card)
		
		# Update the tree state for the next pick
		owned_ids.append(picked_id)
		unlockable_options.erase(picked_id)
		
		# Add new neighbors to the pool
		if picked_id in TREE_CONNECTIONS:
			for neighbor in TREE_CONNECTIONS[picked_id]:
				if neighbor not in owned_ids and neighbor not in unlockable_options:
					unlockable_options.append(neighbor)
	
	# 5. CUT DOWN TO 8 (The Smart Selection)
	# Select the best hand from the large library we just built
	bot_data.deck = _select_smart_hand(bot_data.unlocked_actions, bot_data.ai_archetype)
	
	# 6. Recalculate stats based on the ACTIVE deck
	_recalculate_stats(bot_data)
	
	# Debug Print to verify
	print("\n=== ENEMY GENERATED (" + str(selected_class) + ") ===")
	print("Level: " + str(level) + " | Drafted: " + str(cards_to_draft))
	print("Library Size: " + str(bot_data.unlocked_actions.size()))
	print("Active Deck: " + str(bot_data.deck.size()))
	print("HP: " + str(bot_data.max_hp) + " | SP: " + str(bot_data.max_sp))
	print("==============================\n")
	
	return bot_data

# -------------------------------------------------------------------------
# NEW HELPERS (Needed for the above code)
# -------------------------------------------------------------------------

func _has_card(list: Array, card: ActionData) -> bool:
	for c in list:
		if c.display_name == card.display_name: return true
	return false

func _select_smart_hand(pool: Array[ActionData], _archetype: CharacterData.AIArchetype) -> Array[ActionData]:
	# If we have 8 or fewer, just take them all
	if pool.size() <= HAND_LIMIT:
		return pool.duplicate()
		
	var chosen: Array[ActionData] = []
	var remaining = pool.duplicate()
	
	# 1. PRIORITY: Always take Class Signatures (Non-Basic)
	# We prioritize "cool" cards over "Basic" ones
	for i in range(remaining.size() - 1, -1, -1):
		var c = remaining[i]
		if not c.display_name.begins_with("Basic"):
			chosen.append(c)
			remaining.remove_at(i)
			
	# 2. PRIORITY: Fill remaining slots with Basics
	remaining.shuffle()
	
	while chosen.size() < HAND_LIMIT and remaining.size() > 0:
		chosen.append(remaining.pop_back())
		
	# 3. SAFETY: Ensure at least 1 Opener
	# If we drafted a hand full of "Finishers" or "Cost 3" cards, the bot will break.
	var has_opener = false
	for c in chosen:
		if c.is_opener or c.cost == 0: has_opener = true
	
	if not has_opener:
		# Search the remaining pile for an opener
		for c in remaining:
			if c.is_opener or c.cost == 0:
				# Swap a random card out for this opener
				if chosen.size() > 0:
					chosen.pop_back() 
				chosen.append(c)
				break

	# 4. Trim if we somehow exceeded (though logic prevents it)
	if chosen.size() > HAND_LIMIT:
		chosen.resize(HAND_LIMIT)
		
	return chosen

func _add_neighbors_to_list(node_id: int, owned: Array, available: Array):
	if node_id in TREE_CONNECTIONS:
		for neighbor in TREE_CONNECTIONS[node_id]:
			if neighbor not in owned and neighbor not in available:
				available.append(neighbor)

# Helper for string names
func class_enum_to_string(type: int) -> String:
	match type:
		CharacterData.ClassType.HEAVY: return "Heavy"
		CharacterData.ClassType.PATIENT: return "Patient"
		CharacterData.ClassType.QUICK: return "Quick"
		CharacterData.ClassType.TECHNICAL: return "Technical"
	return "Enemy"
# Generates a fully playable CharacterData resource based on the chosen class
func create_character(type: CharacterData.ClassType, player_name: String) -> CharacterData:
	if not class_registry.has(type): return null
	
	var def: ClassDefinition = class_registry[type]
	var char_data = CharacterData.new()
	
	char_data.character_name = player_name
	char_data.class_type = type
	
	# 1. Base Stats from Resource
	char_data.max_hp = def.base_hp
	char_data.max_sp = def.base_sp
	char_data.speed = def.base_speed
	char_data.passive_desc = def.passive_description
	char_data.portrait = def.portrait
	
	# 2. Library (Duplicate the array so we don't modify the Resource)
	char_data.unlocked_actions = def.starting_deck.duplicate()
	
	# 3. Select Hand
	char_data.deck = _select_smart_hand(char_data.unlocked_actions, char_data.ai_archetype)
	
	char_data.reset_stats()
	return char_data

func get_starting_deck(type: CharacterData.ClassType) -> Array[ActionData]:
	var deck: Array[ActionData] = []
	
	# --- ADD BASIC CARDS (Common to all) ---
	# We use load() to turn the file path into a usable Object
	deck.append(load("res://Data/Actions/basic_light.tres"))
	deck.append(load("res://Data/Actions/basic_heavy.tres"))
	deck.append(load("res://Data/Actions/basic_technical.tres"))
	deck.append(load("res://Data/Actions/basic_positioning.tres"))
	deck.append(load("res://Data/Actions/basic_block.tres"))
	deck.append(load("res://Data/Actions/basic_dodge.tres")) # This fixes line 41
	deck.append(load("res://Data/Actions/basic_parry.tres"))
	deck.append(load("res://Data/Actions/basic_reversal.tres"))
	
	# --- ADD CLASS EXCLUSIVES ---
	match type:
		CharacterData.ClassType.HEAVY:
			deck.append(load("res://Data/Actions/haymaker.tres"))
			deck.append(load("res://Data/Actions/elbow_block.tres"))
			
		CharacterData.ClassType.PATIENT:
			deck.append(load("res://Data/Actions/preparation.tres"))
			deck.append(load("res://Data/Actions/counter_strike.tres"))
			
		CharacterData.ClassType.QUICK:
			deck.append(load("res://Data/Actions/roll_punch.tres"))
			deck.append(load("res://Data/Actions/weave.tres"))
			
		CharacterData.ClassType.TECHNICAL:
			deck.append(load("res://Data/Actions/discombobulate.tres"))
			deck.append(load("res://Data/Actions/hand_catch.tres"))
			
	return deck

func create_from_preset(preset: PresetCharacter) -> CharacterData:
	# 1. Start with the Base Class (Starters + Basic Actions)
	var char_data = create_character(preset.class_type, preset.character_name)
	
	# 2. Add the Extra Skills defined in the preset
	for skill_name in preset.extra_skills:
		var card = find_action_resource(skill_name)
		if card:
			# Avoid duplicates if necessary, or allow multiples if that's your game design
			char_data.deck.append(card)
			char_data.unlocked_actions.append(card)
		else:
			printerr("Warning: Preset '" + preset.character_name + "' could not find skill: " + skill_name)

	# 3. Auto-Calculate Stats based on Class Rules
	_recalculate_stats(char_data)
	
	return char_data

# --- HELPER: Stat Calculation Logic (Same rules as ActionTree) ---
# ClassFactory.gd

func _recalculate_stats(char_data: CharacterData):
	# 1. Snapshot old stats before we change them
	var old_max_hp = char_data.max_hp
	
	# 2. Calculate new stats
	var result = calculate_stats_for_deck(char_data.class_type, char_data.unlocked_actions, char_data.equipment)
	
	char_data.max_hp = result["hp"]
	char_data.max_sp = result["sp"]
	
	# --- 3. ROGUELIKE HP LOGIC ---
	if RunManager.is_arcade_mode and RunManager.maintain_hp_enabled:
		# Only heal them by the AMOUNT they grew (e.g., Max HP 5 -> 6 means heal 1 HP)
		var hp_growth = char_data.max_hp - old_max_hp
		char_data.current_hp += hp_growth
		char_data.current_sp = char_data.max_sp # SP always resets per fight
	else:
		# Standard Mode: Full Heal
		char_data.current_hp = char_data.max_hp
		char_data.current_sp = char_data.max_sp


# --- HELPER: Find Resource (Moved from ActionTree) ---
func find_action_resource(action_name: String) -> ActionData:
	var clean_name = action_name.to_lower().replace(" ", "_")
	var filename = clean_name + ".tres"
	
	# Check Common folder
	var common_path = "res://Data/Actions/" + filename
	if ResourceLoader.exists(common_path): return load(common_path)
		
	# Check Class folders
	var class_folders = ["Heavy", "Patient", "Quick", "Technical"]
	for folder in class_folders:
		var class_path = "res://Data/Actions/Class/" + folder + "/" + filename
		if ResourceLoader.exists(class_path): return load(class_path)
			
	return null

# New Helper Function: Accepts a Class Type and a List of Cards -> Returns Stats
func calculate_stats_for_deck(type: CharacterData.ClassType, deck: Array[ActionData], equipment: Array[EquipmentData] = []) -> Dictionary:
	if not class_registry.has(type): return {"hp": 5, "sp": 4}
	
	var def: ClassDefinition = class_registry[type]
	var final_hp = def.base_hp
	var final_sp = def.base_sp
	
	# 1. Get Ignore List from the definition
	var ignore_names = []
	for c in def.starting_deck:
		ignore_names.append(c.display_name)
		
	# 2. Calculate
	for card in deck:
		if card == null: continue
		if card.display_name in ignore_names or card.display_name.begins_with("Basic"):
			continue
			
		# 3. GENERIC MATH (Reads from Resource)
		if card.type == ActionData.Type.OFFENCE:
			final_hp += def.offence_hp_growth
			final_sp += def.offence_sp_growth
		elif card.type == ActionData.Type.DEFENCE:
			final_hp += def.defence_hp_growth
			final_sp += def.defence_sp_growth
	
	for item in equipment:
		final_hp += item.max_hp_bonus
		final_sp += item.max_sp_bonus
			
	return {"hp": max(1, final_hp), "sp": max(1, final_sp)} # Clamp to 1 so items can't kill you

# NEW HELPER: Reverse lookup for Presets -> Tree Nodes
func get_id_by_name(card_name: String) -> int:
	for id in ID_TO_NAME_MAP:
		if ID_TO_NAME_MAP[id] == card_name:
			return id
	return 0 # Not found

func _simulate_draft_ids(class_type, count) -> Array:
	var root_id = 76 # Heavy
	match class_type:
		CharacterData.ClassType.QUICK: root_id = 73
		CharacterData.ClassType.TECHNICAL: root_id = 74
		CharacterData.ClassType.PATIENT: root_id = 75
	
	var owned = [root_id]
	var available = []
	_add_neighbors_to_list(root_id, owned, available)
	
	var results = []
	for i in range(count):
		if available.is_empty(): break
		var pick = available.pick_random()
		results.append(pick)
		owned.append(pick)
		available.erase(pick)
		_add_neighbors_to_list(pick, owned, available)
		
	return results


========================================
FILE PATH: res://Scripts/CombatLog.gd
========================================
extends PanelContainer

# --- VISUAL REFERENCES ---
var scroll_container: ScrollContainer
var log_list: VBoxContainer
var tooltip_popup: PanelContainer
var left_card_preview
var right_card_preview

# Colors
const P1_COLOR = "#ff9999" 
const P2_COLOR = "#99ccff"
const HOVER_COLOR = Color(0.2, 0.2, 0.2, 0.8) 
const NORMAL_COLOR = Color(0, 0, 0, 0)        

var card_scene = preload("res://Scenes/CardDisplay.tscn")

func _ready():
	# 1. CLEANUP
	for child in get_children():
		child.queue_free()
	
	# 2. CREATE SCROLL LIST
	scroll_container = ScrollContainer.new()
	scroll_container.horizontal_scroll_mode = ScrollContainer.SCROLL_MODE_DISABLED
	scroll_container.size_flags_vertical = Control.SIZE_EXPAND_FILL
	add_child(scroll_container)
	
	log_list = VBoxContainer.new()
	log_list.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	log_list.size_flags_vertical = Control.SIZE_EXPAND_FILL
	log_list.add_theme_constant_override("separation", 2) 
	scroll_container.add_child(log_list)
	
	# 3. CREATE TOOLTIP POPUP
	_create_tooltip_popup()
	
	# --- FIX: Listen for when the player opens the log ---
	visibility_changed.connect(_on_visibility_changed)

func _create_tooltip_popup():
	tooltip_popup = PanelContainer.new()
	tooltip_popup.visible = false
	tooltip_popup.mouse_filter = Control.MOUSE_FILTER_IGNORE 
	
	# CRITICAL FIX: Break out of the ScrollContainer's bounds
	tooltip_popup.set_as_top_level(true)
	tooltip_popup.z_index = 100 
	
	var hbox = HBoxContainer.new()
	hbox.add_theme_constant_override("separation", 10)
	tooltip_popup.add_child(hbox)
	
	left_card_preview = card_scene.instantiate()
	left_card_preview.custom_minimum_size = Vector2(150, 210)
	left_card_preview.scale = Vector2(0.6, 0.6)
	hbox.add_child(left_card_preview)
	
	var vs_lbl = Label.new()
	vs_lbl.text = "VS"
	hbox.add_child(vs_lbl)
	
	right_card_preview = card_scene.instantiate()
	right_card_preview.custom_minimum_size = Vector2(150, 210)
	right_card_preview.scale = Vector2(0.6, 0.6)
	hbox.add_child(right_card_preview)
	
	# Add to self (CombatLog), but 'set_as_top_level' makes it float globally
	add_child(tooltip_popup)

# --- PUBLIC FUNCTIONS ---

func add_log(text: String):
	var row = MarginContainer.new()
	row.add_theme_constant_override("margin_left", 5)
	
	var label = _create_rich_label(text)
	row.add_child(label)
	
	log_list.add_child(row)
	_auto_scroll()

func add_clash_log(winner_id: int, p1_card: ActionData, p2_card: ActionData):
	# 1. ROOT CONTAINER (MarginContainer)
	# Handles layout so rows don't crush each other
	var row = MarginContainer.new()
	row.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	row.mouse_filter = Control.MOUSE_FILTER_IGNORE 
	
	# 2. TEXT CONTENT
	var win_text = "COMPLETE"
	var color = "#24ab4a"
	if winner_id == 1: pass
		#win_text = "P1 WON"
		#color = P1_COLOR
	elif winner_id == 2: pass
		#win_text = "P2 WON"
		#color = P2_COLOR
		
	var txt = "[color=%s]>>> CLASH!: %s (Hover to view)[/color]" % [color, win_text]
	var label = _create_rich_label(txt)
	
	var text_margin = MarginContainer.new()
	text_margin.mouse_filter = Control.MOUSE_FILTER_IGNORE
	text_margin.add_theme_constant_override("margin_left", 5)
	text_margin.add_theme_constant_override("margin_top", 2)
	text_margin.add_theme_constant_override("margin_bottom", 2)
	text_margin.add_child(label)
	
	row.add_child(text_margin)
	
	# 3. BUTTON OVERLAY
	# Handles Interaction
	var btn = Button.new()
	
	btn.mouse_entered.connect(func(): AudioManager.play_sfx("ui_hover", 0.2))
	btn.pressed.connect(func(): AudioManager.play_sfx("ui_click"))
	
	btn.mouse_filter = Control.MOUSE_FILTER_STOP
	btn.mouse_default_cursor_shape = Control.CURSOR_POINTING_HAND
	btn.flat = true 
	
	# Styles
	var style_hover = StyleBoxFlat.new()
	style_hover.bg_color = HOVER_COLOR
	btn.add_theme_stylebox_override("hover", style_hover)
	btn.add_theme_stylebox_override("pressed", style_hover)
	btn.add_theme_stylebox_override("normal", StyleBoxEmpty.new())
	btn.add_theme_stylebox_override("focus", StyleBoxEmpty.new())
	
	# Signals
	btn.mouse_entered.connect(func(): _on_row_hovered(btn, p1_card, p2_card))
	btn.mouse_exited.connect(func(): _on_row_exited())
	
	row.add_child(btn)
	log_list.add_child(row)
	_auto_scroll()

func clear_log():
	for child in log_list.get_children():
		child.queue_free()

# --- HELPERS ---

func _create_rich_label(text: String) -> RichTextLabel:
	var l = RichTextLabel.new()
	l.bbcode_enabled = true
	l.text = _format_text(text)
	l.fit_content = true 
	l.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	l.mouse_filter = Control.MOUSE_FILTER_IGNORE 
	return l

func _format_text(raw: String) -> String:
	var txt = raw.replace("P1", "[color=" + P1_COLOR + "]P1[/color]")
	txt = txt.replace("P2", "[color=" + P2_COLOR + "]P2[/color]")
	if ">>" in txt: txt = "[color=#aaaaaa][i]" + txt + "[/i][/color]"
	return txt

func _auto_scroll():
	# Only scroll if we are actually visible to avoid errors
	if not visible: return
	
	await get_tree().process_frame
	await get_tree().process_frame
	
	if scroll_container and scroll_container.get_v_scroll_bar():
		scroll_container.scroll_vertical = int(scroll_container.get_v_scroll_bar().max_value)

# --- INTERACTIVITY ---

func _on_row_hovered(_btn: Button, c1: ActionData, c2: ActionData):
	# 1. Update Content
	if left_card_preview.has_method("set_card_data"):
		left_card_preview.set_card_data(c1)
		right_card_preview.set_card_data(c2)
	
	# 2. Position Popup
	tooltip_popup.visible = true
	tooltip_popup.reset_size() 
	
	## 3. Calculate Global Position
	## 'set_as_top_level' means we use screen coordinates.
	## 'btn.global_position' gives us the button's exact screen location.
	#var popup_height = 250
	#var target_y = btn.global_position.y - popup_height - 70
	#
	## Logic: If row is too high (near top of screen), show BELOW the row instead
	#if target_y < 0:
		#target_y = btn.global_position.y + btn.size.y + 20
		#
	#var target_x = global_position.x + 200
	#
	#tooltip_popup.global_position = Vector2(target_x, target_y)
	tooltip_popup.global_position = get_viewport().get_mouse_position()

	
func _on_row_exited():
	tooltip_popup.visible = false

func add_round_summary(p1_diff: Dictionary, p2_diff: Dictionary, mom_val: int):
	# Create a simple row container
	var row = MarginContainer.new()
	row.add_theme_constant_override("margin_left", 20) # Indent slightly
	row.add_theme_constant_override("margin_bottom", 5)
	
	# Format the text
	var p1_text = _format_diff("P1", p1_diff, P1_COLOR)
	var p2_text = _format_diff("P2", p2_diff, P2_COLOR)
	var mom_text = " | Mom: [color=yellow]" + str(mom_val) + "[/color]"
	
	# --- NEW: COMBO COUNTER ---
	var combo_text = ""
	var attacker = GameManager.get_attacker()
	
	# Check if P1 is comboing
	if attacker == 1 and GameManager.p1_data.combo_action_count > 1:
		combo_text = " | [color=#ff9999][b]P1 COMBO: " + str(GameManager.p1_data.combo_action_count) + " HITS![/b][/color]"
	# Check if P2 is comboing
	elif attacker == 2 and GameManager.p2_data.combo_action_count > 1:
		combo_text = " | [color=#99ccff][b]P2 COMBO: " + str(GameManager.p2_data.combo_action_count) + " HITS![/b][/color]"
	# --------------------------
	
	var final_bbcode = p1_text + "   " + p2_text + mom_text + combo_text + "\n [b]----------- NEW CLASH -----------[/b]"
	
	var label = _create_rich_label(final_bbcode)
	row.add_child(label)
	
	log_list.add_child(row)
	_auto_scroll()

# Helper to format changes (e.g., "-5 HP" in red, "+2 SP" in green)
func _format_diff(player_label: String, diff: Dictionary, name_color: String) -> String:
	var s = "[color=" + name_color + "]" + player_label + ":[/color] "
	var changes = []
	
	# HP Change
	if diff.hp != 0:
		var c = "red" if diff.hp < 0 else "green"
		# RENAMED VARIABLE: 'sign' -> 'sign_str'
		var sign_str = "+" if diff.hp > 0 else ""
		changes.append("[color=" + c + "]" + sign_str + str(diff.hp) + " HP[/color]")
		
	# SP Change
	if diff.sp != 0:
		var c = "red" if diff.sp < 0 else "green"
		# RENAMED VARIABLE: 'sign' -> 'sign_str'
		var sign_str = "+" if diff.sp > 0 else ""
		changes.append("[color=" + c + "]" + sign_str + str(diff.sp) + " SP[/color]")
		
	if changes.is_empty():
		return s + "[color=#888888]No Change[/color]"
		
	return s + ", ".join(changes)

func _on_visibility_changed():
	# If we just opened the window, wait for it to draw, then scroll to bottom.
	if visible:
		_auto_scroll()


========================================
FILE PATH: res://Scripts/compendium.gd
========================================
extends Control

@onready var keyword_container = $TabContainer/Traits/MarginContainer/VBoxContainer
@onready var combat_container = $TabContainer/Combat/MarginContainer/VBoxContainer
@onready var card_grid = $"TabContainer/Card Library/MarginContainer/GridContainer"
@onready var rules_container = $"TabContainer/Rules/MarginContainer/VBoxContainer"
@onready var modes_container = $TabContainer/Modes/MarginContainer/VBoxContainer
@onready var tab_container = $TabContainer # <--- NEW
@onready var back_button = $BackButton

# New variable to control which tab opens first
var initial_tab_index: int = 0

const RULES_DEFS = {
	"Actions": "An action is a move, technique or attack that is used in combat. Every action has a number of traits that convey how the action works.",
	"Passive Abilities": "Passive enhancements that affect all actions. Everyone gets a passive ability from their chosen class.",
	"Combo": "A combo is one or more Offence actions used in a row, without having to check the momentum advantage.",
	"Traits": "All actions have one or more traits. A trait is a keyword that conveys information about how an action interacts with other rules elements or traits. Traits can stack unless otherwise noted. Actions are sometimes named for their traits, e.g. an action with the Offence trait is called and Offence action.", 
	"Stamina": "Every combatant has a number of stamina points (SP), which is used to keep track of their current stamina as it increases and falls throughout a combat. Player characters start with 3 SP. Stamina can be increased and reduced by you or your opponents actions and special abilities.", 
	"Health": "Every combatant has a number of hit points (HP) that they must keep track of. Player characters start with 10 HP. Actions can deal damage to you to reduce your HP, or heal yourself to increase your HP (up to your max HP).", 
	"Momentum": "Momentum keeps track of who has taken the advantage in combat. It is suggested that momentum is tracked using one polyhedral die, but any even number can be used. Each combatant chooses either high or low numbers to be theirs. Any time a player is in their half of the tracker, they have the momentum advantage, and can use offence actions in combat (once their opponent's combo has ended). Example: With a momentum of 8, player A chooses high numbers, so 5-8, and player B chooses low numbers, so 1-4. Whenever player A would gain momentum, through actions or special abilities, they would increase the number. Conversely, whenever player B would gain momentum, they would decrease the number. For example, if momentum is on 2, player B has the momentum advantage, and if the momentum was 1, player A would first take SP damage if they use fall back actions, or HP if they are out of SP.", 
	"Order of Actions": "When you apply the traits from an action to yourself, please use the following rules:  Apply traits from your action to yourself before you apply traits from your opponents action to yourself  Apply traits that affect the momentum tracker from Offence actions first, then Defence actions."
}

const COMBAT_DEFS = {
	"Combat Rules": "A combat is a 1v1 fight between two 'combatants'. These could be between player characters, non-player characters, or any combination of the two.",
	"Structure": "A Combat is played out in a series of Clashes.",
	"Clash": "Two combatants choose an action secretly, and resolve the results.",
	"Combat": "Combatants resolve clashes until one of them is defeated by losing all their health.",
	"Step 1: Set Stamina and Health": "At the start of every combat, each combatant normally has their maximum stamina and health, however this could be reduced by things like previous fights or environmental effects.",
	"Step 2: Choose Momentum": "The momentum tracker is chosen by the referee, and each combatant chooses which half of the tracker they wish to use, high or low. A priority token is also awarded to the player whose class has the highest speed. If the classes are the same, decide randomly, such as with a coin flip.",
	"Step 3: Initial Clash ": "The combatants then start with an initial clash, where both combatants secretly choose an action. As no one has a momentum advantage yet, both combatants can choose Offence or Defence actions. The combatants then reveal their actions, and the momentum advantage is awarded as follows: 	If one combatant chooses an action with the Offence trait, and one combatant chooses and action with the Defense trait, the combatant that chose the Offence action is awarded the momentum advantage. 	If the traits are the same, the action with lower stamina interrupts the other, taking the momentum advantage. If the stamina is also the same, the player with the priority token goes first, and the priority token switches to the other player. Whichever combatant is awarded the momentum advantage sets the momentum tracker to the number on their half closest to the center (e.g. 4 for Low, 5 for High).. The combatant with the momentum advantage is now on the attack, and can only use actions with the Offence trait, while the other combatant can only use actions with the Defence trait.",
	"Step 4: Resolve Initial Actions ": "The combatants now resolve the effects of their actions, such as using stamina, but ignore any momentum gain or loss from their actions.",
	"Step 5: Clashes ": "Now that the initial clash is resolved, combat can continue as normal. The combatant that is on the attack can continue their combo. When a combo is over, the momentum is checked. A combatant can choose to end their own combo at any time. Whichever combatant has the momentum advantage is now on the offence, and the other combatant is now on the defence. Each clash, combatants secretly choose a move, a his repeats until a combatant loses all their health."
}

var MODES_DEFS = {
		"Quick Match": "A single battle against an AI opponent. You choose a basic class loadout or a preset deck. Great for testing mechanics or a quick fight. \n\n- Simply choose a character for you and your opponent, toggle between CPU and Human for player 2, choose a CPU difficulty, then select Quick CLASH! to get right into the action",
		"Quick Match (build action list)": "Just like regular Quick Match, except you create an action loadout for P1, and P2 if they are human!",
		"Arcade Mode": "Continuous battles against random opponents with a hand limit of 8, where you unlock a new action after each victory. If you lose a match, the run ends. \n\n- Choose a basic class to start from scratch or a premade character to start at a higher level, choose the NPC difficulty, then select Start Arcade Run!."
	}

# We need the CardDisplay scene to spawn cards
var card_scene = preload("res://Scenes/CardDisplay.tscn")

var is_overlay: bool = false # Default is False (Main Menu Mode)

func _ready():
	back_button.pressed.connect(_on_back_pressed)
	
	# Consolidated calls
	_populate_section(keyword_container, GameManager.KEYWORD_DEFS)
	_populate_section(rules_container, RULES_DEFS)
	_populate_section(combat_container, COMBAT_DEFS)
	_populate_section(modes_container, MODES_DEFS)
	
	_populate_card_library()
	
	if is_overlay:
		back_button.text = "Close Help"
	
	tab_container.current_tab = initial_tab_index

func _populate_card_library():
	# We use the ID map from ClassFactory to find every card
	var all_ids = ClassFactory.ID_TO_NAME_MAP.keys()
	all_ids.sort() # Keep them in order
	
	for id in all_ids:
		# skip class nodes
		if id >= 73: continue 
		
		var card_name = ClassFactory.ID_TO_NAME_MAP[id]
		var card_data = ClassFactory.find_action_resource(card_name)
		
		if card_data:
			var display = card_scene.instantiate()
			card_grid.add_child(display)
			
			# Setup visuals
			display.set_card_data(card_data)
			display.custom_minimum_size = Vector2(200, 280) # Smaller version
			display.scale = Vector2(0.8, 0.8) # Shrink to fit more

func _on_back_pressed():
	if is_overlay:
		# Just close this window, don't restart the game!
		queue_free()
	else:
		# Go back to Main Menu
		SceneLoader.change_scene("res://Scenes/MainMenu.tscn")

func _populate_section(container: Control, data: Dictionary):
	for key in data:
		var text_value = data[key]
		
		var l = RichTextLabel.new()
		l.bbcode_enabled = true
		l.text = "[b][color=yellow]" + key + ":[/color][/b] " + text_value
		l.fit_content = true
		l.custom_minimum_size.y = 50 
		
		container.add_child(l)


========================================
FILE PATH: res://Scripts/equipmentdraft.gd
========================================
extends Control

@onready var item_grid = $ColorRect/ItemGrid

func _ready():
	# 1. Get all available equipment
	var all_items = RunManager.get_all_equipment()
	all_items.shuffle() # Randomize the list
	
	# 2. Pick the top 3 (or fewer if you haven't made 3 items yet)
	var options = []
	for i in range(min(3, all_items.size())):
		options.append(all_items[i])
		
	# 3. Create Buttons
	for item in options:
		var btn = _create_item_button(item)
		item_grid.add_child(btn)

func _create_item_button(item: EquipmentData) -> Button:
	var btn = Button.new()
	btn.custom_minimum_size = Vector2(250, 350)
	btn.mouse_default_cursor_shape = Control.CURSOR_POINTING_HAND
	
	# Styling
	var style = StyleBoxFlat.new()
	style.bg_color = Color(0.15, 0.15, 0.15)
	style.set_corner_radius_all(10)
	btn.add_theme_stylebox_override("normal", style)
	
	# Content Container
	var vbox = VBoxContainer.new()
	vbox.set_anchors_and_offsets_preset(Control.PRESET_FULL_RECT)
	vbox.add_theme_constant_override("separation", 10)
	btn.add_child(vbox)
	
	# Icon
	var icon = TextureRect.new()
	icon.custom_minimum_size.y = 100
	icon.stretch_mode = TextureRect.STRETCH_KEEP_ASPECT_CENTERED
	icon.texture = item.icon if item.icon else preload("res://icon.svg")
	vbox.add_child(icon)
	
	# Name
	var name_lbl = Label.new()
	name_lbl.text = item.display_name
	name_lbl.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	name_lbl.add_theme_font_size_override("font_size", 24)
	vbox.add_child(name_lbl)
	
	# Description
	var desc_lbl = Label.new()
	desc_lbl.text = item.description
	desc_lbl.autowrap_mode = TextServer.AUTOWRAP_WORD
	desc_lbl.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	vbox.add_child(desc_lbl)
	
	# Click Logic
	btn.pressed.connect(func(): _on_item_selected(item))
	btn.mouse_entered.connect(func(): AudioManager.play_sfx("ui_hover", 0.2))
	
	return btn

func _on_item_selected(item: EquipmentData):
	AudioManager.play_sfx("ui_click")
	print("Equipped: " + item.display_name)
	
	# 1. Add to inventory
	RunManager.player_run_data.equipment.append(item)
	
	# 2. Recalculate stats immediately so max HP/SP increases
	ClassFactory._recalculate_stats(RunManager.player_run_data)
	
	# 3. Proceed to the Action Tree for the card reward
	SceneLoader.change_scene("res://Scenes/ActionTree.tscn")


========================================
FILE PATH: res://Scripts/EventRoom.gd
========================================
extends Control

@onready var title_label = $VBoxContainer/TitleLabel
@onready var desc_label = $VBoxContainer/DescriptionLabel
@onready var btn_a = $VBoxContainer/OptionA
@onready var btn_b = $VBoxContainer/OptionB
@onready var btn_c = $VBoxContainer/OptionC

# The ID of the current event
var current_event_id: String = ""

func _ready():
	# For now we only have the Medic, but later we can do:
	# current_event_id = ["medic", "bookie", "zen"].pick_random()
	current_event_id = "medic" 
	
	_load_event(current_event_id)
	
	# Connect buttons to a single handler
	btn_a.pressed.connect(func(): _on_option_selected(1))
	btn_b.pressed.connect(func(): _on_option_selected(2))
	btn_c.pressed.connect(func(): _on_option_selected(3))
	
	# UI Juice
	for btn in [btn_a, btn_b, btn_c]:
		btn.mouse_entered.connect(func(): AudioManager.play_sfx("ui_hover", 0.2))

# ==============================================================================
# EVENT DEFINITIONS (Easy to expand!)
# ==============================================================================
func _load_event(id: String):
	match id:
		"medic":
			title_label.text = "THE BACK-ALLEY MEDIC"
			desc_label.text = "A shady doctor leans out of a doorway. [i]'Rough fight, champ? I can patch you up. Or, if you're feeling brave, I have some new experimental supplements you can try.'[/i]"
			btn_a.text = "PATCH UP (Heal 3 HP)"
			btn_b.text = "TAKE DRUGS (+1 Max SP, unknown side effects)"
			btn_c.text = "WALK AWAY (Nothing happens)"

# ==============================================================================
# EVENT RESOLUTION LOGIC
# ==============================================================================
func _on_option_selected(choice: int):
	AudioManager.play_sfx("ui_click")
	var p1 = RunManager.player_run_data
	
	# --- 1. RESOLVE THE MEDIC ---
	if current_event_id == "medic":
		match choice:
			1: # PATCH UP
				p1.current_hp = min(p1.current_hp + 3, p1.max_hp)
				print("Event: Healed 3 HP.")
			2: # TAKE DRUGS
				# We create a permanent piece of equipment on the fly!
				var drugs = EquipmentData.new()
				drugs.display_name = "Experimental Drugs"
				drugs.description = "Side effects include sweating and nausea."
				drugs.max_sp_bonus = 1
				p1.equipment.append(drugs)
				
				# Add the penalty for the next fight
				RunManager.next_fight_statuses.append("Injured")
				print("Event: Gained Drugs. Injured next fight.")
			3: # WALK AWAY
				print("Event: Walked away.")

	# --- 2. CLEANUP & LEAVE ---
	# Recalculate stats so the Max SP bonus applies immediately
	ClassFactory._recalculate_stats(p1)
	
	# Proceed to the Action Tree to get your card reward for the level
	SceneLoader.change_scene("res://Scenes/ActionTree.tscn")


========================================
FILE PATH: res://Scripts/FloatingText.gd
========================================
extends Node2D

@onready var label = $Label

func _ready():
	# Ensure it sits on top of other UI elements
	z_index = 20

func setup(text_value: String, color: Color, start_pos: Vector2):
	# 1. Setup Initial State
	position = start_pos
	
	if label:
		label.text = text_value
		label.modulate = color
	
	# 2. Randomize Movement (The "Drift")
	var drift_x = randf_range(-60, 60)
	var float_height = -100 # How high it goes
	var duration = 1.0
	
	# 3. Create Animation Tween
	var tween = create_tween()
	tween.set_parallel(true) # Run all tweens at once
	tween.set_trans(Tween.TRANS_CUBIC).set_ease(Tween.EASE_OUT)
	
	# MOVEMENT: Drift sideways and float up
	tween.tween_property(self, "position", start_pos + Vector2(drift_x, float_height), duration)
	
	# SCALE: Pop in (Start big, shrink to normal)
	scale = Vector2(1.5, 1.5)
	tween.tween_property(self, "scale", Vector2(1.0, 1.0), 0.3).set_trans(Tween.TRANS_BACK)
	
	# FADE: Disappear at the end
	# Wait 0.5s, then fade out over the remaining 0.5s
	tween.tween_property(self, "modulate:a", 0.0, 0.5).set_delay(0.5)
	
	# 4. Cleanup
	await tween.finished
	queue_free()


========================================
FILE PATH: res://Scripts/GameOverScreen.gd
========================================
extends Control

@onready var winner_label = $Panel/VBoxContainer/WinnerLabel
@onready var main_panel = $Panel
@onready var vbox = $Panel/VBoxContainer
@onready var background_rect = $Background

var view_board_btn: Button
var stats_panel: RichTextLabel

func _ready():
	# 1. Get Existing References
	var btn_rematch = $Panel/VBoxContainer/RematchButton
	var btn_menu = $Panel/VBoxContainer/MenuButton
	
	# 2. Connect Logic
	btn_rematch.pressed.connect(_on_rematch_pressed)
	btn_menu.pressed.connect(_on_menu_pressed)
	_attach_sfx(btn_rematch)
	_attach_sfx(btn_menu)
	
	# 3. Add "VIEW BOARD" Button (Dynamically created)
	view_board_btn = Button.new()
	view_board_btn.text = "Hide Screen (View Board)"
	view_board_btn.pressed.connect(_on_view_board_pressed)
	_attach_sfx(view_board_btn)
	
	# Add it to the top right of the screen
	add_child(view_board_btn)
	view_board_btn.set_anchors_and_offsets_preset(Control.PRESET_TOP_RIGHT)
	view_board_btn.position -= Vector2(20, -20)
	
	# 4. Create Run Stats Container (Hidden by default)
	stats_panel = RichTextLabel.new()
	stats_panel.bbcode_enabled = true
	stats_panel.fit_content = true
	stats_panel.custom_minimum_size.y = 100
	stats_panel.visible = false
	vbox.add_child(stats_panel)
	vbox.move_child(stats_panel, 1) # Put it under the Winner Label

func setup(winner_id: int):
	# --- STANDARD SETUP ---
	if winner_id == 1:
		winner_label.text = "PLAYER 1 WINS!"
		winner_label.modulate = Color("#ff9999")
	elif winner_id == 2:
		winner_label.text = "PLAYER 2 WINS!"
		winner_label.modulate = Color("#99ccff")
	else:
		winner_label.text = "DRAW!"

	# --- ARCADE LOGIC & STATS ---
	if RunManager.is_arcade_mode:
		if winner_id == 1:
			# Player Won: Proceed to next level
			$Panel/VBoxContainer/RematchButton.text = "CLAIM REWARD"
			$Panel/VBoxContainer/RematchButton.pressed.disconnect(_on_rematch_pressed)
			$Panel/VBoxContainer/RematchButton.pressed.connect(_on_claim_reward_pressed)
			
		else:
			# Player Lost: SHOW RUN SUMMARY
			$Panel/VBoxContainer/RematchButton.visible = false 
			$Panel/VBoxContainer/MenuButton.text = "MAIN MENU"
			
			_populate_run_stats()

func _populate_run_stats():
	stats_panel.visible = true
	
	# 1. Basic Stats
	var levels_beat = RunManager.current_level - 1
	var txt = "[center][b]--- ARCADE RUN SUMMARY ---[/b][/center]\n\n"
	txt += "[color=yellow]Enemies Defeated:[/color] " + str(levels_beat) + "\n"
	
	# 2. Deck Summary
	txt += "[color=yellow]Final Deck:[/color] "
	var deck_names = []
	for card in RunManager.player_run_data.deck:
		deck_names.append(card.display_name)
	txt += ", ".join(deck_names) + "\n"
	
	# 3. Placeholder for Future Stats
	txt += "\n[color=gray][i]Total Damage Dealt: (Coming Soon)[/i][/color]"
	txt += "\n[color=gray][i]Total SP Spent: (Coming Soon)[/i][/color]"
	
	stats_panel.text = txt

# --- UI INTERACTION ---

func _on_view_board_pressed():
	# Toggle visibility of the visuals
	main_panel.visible = not main_panel.visible
	background_rect.visible = not background_rect.visible 
	
	if main_panel.visible:
		view_board_btn.text = "Hide Screen (View Board)"
		# --- FIX: Block clicks from passing through ---
		mouse_filter = Control.MOUSE_FILTER_STOP 
	else:
		view_board_btn.text = "Show Game Over Screen"
		# --- FIX: Let clicks pass through the invisible root node ---
		mouse_filter = Control.MOUSE_FILTER_IGNORE

func _on_rematch_pressed():
	# --- FIX: Unpause before reloading ---
	get_tree().paused = false 
	# -------------------------------------
	GameManager.reset_combat() 
	get_tree().reload_current_scene()

func _on_menu_pressed():
	# --- FIX: Unpause before leaving ---
	get_tree().paused = false 
	# -----------------------------------
	GameManager.reset_combat() 
	SceneLoader.change_scene("res://Scenes/MainMenu.tscn")
	
func _attach_sfx(btn: BaseButton):
	btn.mouse_entered.connect(func(): AudioManager.play_sfx("ui_hover", 0.2))
	btn.pressed.connect(func(): AudioManager.play_sfx("ui_click"))

func _on_claim_reward_pressed():
	# 1. Unpause the game safely
	get_tree().paused = false
	
	# 2. Tell the RunManager to load the Action Tree
	RunManager.handle_win()


========================================
FILE PATH: res://Scripts/HitStopManager.gd
========================================
extends Node

var _stop_id: int = 0

func _ready():
	process_mode = Node.PROCESS_MODE_ALWAYS # Must run even when paused
	GameManager.damage_dealt.connect(_on_damage)

func _on_damage(_target, amount, is_blocked):
	if is_blocked: return # No freeze on blocks
	
	# Only freeze on significant hits
	if amount >= 3:
		stop_frame(0.15)
	elif amount > 0:
		stop_frame(0.05)

func stop_frame(duration: float):
	# 1. Increment ID
	# This invalidates any previous timers that are currently waiting.
	_stop_id += 1
	var current_id = _stop_id
	
	# 2. Freeze
	get_tree().paused = true
	
	# 3. Wait
	# We use a timer that ignores the game pause state
	await get_tree().create_timer(duration, true, false, true).timeout
	
	# 4. Check ID
	# Only unpause if WE are still the active timer. 
	# If stop_frame() was called again while we were waiting (e.g. by the Finisher),
	# _stop_id will be higher, and we will do nothing.
	if _stop_id == current_id:
		get_tree().paused = false


========================================
FILE PATH: res://Scripts/LinesLayer.gd
========================================
# LinesLayer.gd
extends Control

@export var line_color: Color = Color.WHITE
@export var line_width: float = 2.0

func _draw():
	var tree_root = owner         # <-- This finds the actual ActionTree root

	# Safety check to prevent errors if the scene isn't fully ready
	if not tree_root or not "action_tree_dict" in tree_root:
		return

	var dict = tree_root.action_tree_dict
	
	# We can grab the nodes_layer directly from the root now that you fixed the path there
	var nodes_container = tree_root.nodes_layer
	
	if not nodes_container:
		return
	# We need to find where the nodes are
	var node_map = {}
	for child in nodes_container.get_children():
		node_map[int(str(child.name))] = child
		
	# Draw lines
	for start_id in dict:
		if not start_id in node_map: continue
		var start_node = node_map[start_id]
		var start_pos = start_node.position + (start_node.size / 2)
		
		for end_id in dict[start_id]:
			if not end_id in node_map: continue
			var end_node = node_map[end_id]
			var end_pos = end_node.position + (end_node.size / 2)
			
			draw_line(start_pos, end_pos, line_color, line_width)


========================================
FILE PATH: res://Scripts/MainMenu.gd
========================================
extends Control

func _ready():
	# Connect buttons dynamically or via editor signals
	$VBoxContainer/StartButton.pressed.connect(_on_start_pressed)
	$VBoxContainer/QuitButton.pressed.connect(_on_quit_pressed)
	
	_attach_sfx($VBoxContainer/StartButton)
	_attach_sfx($VBoxContainer/QuitButton)
	_attach_sfx($VBoxContainer/CompendiumButton)
	
	var btn_compendium = find_child("CompendiumButton") # Or reference it directly if you prefer
	if btn_compendium:
		btn_compendium.pressed.connect(_on_compendium_pressed)
	
func _on_start_pressed():
	# Assumes your main arena scene is saved here
	#SceneLoader.change_scene("res://Scenes/MainScene.tscn")
	#SceneLoader.change_scene("res://Scenes/CharacterSelect.tscn")
	#SceneLoader.change_scene("res://Scenes/CharacterSelect.tscn")
	SceneLoader.change_scene("res://Scenes/CarouselHub.tscn")
	
func _on_quit_pressed():
	get_tree().quit()

func _on_compendium_pressed():
	SceneLoader.change_scene("res://Scenes/compendium.tscn")

func _attach_sfx(btn: BaseButton):
	if not btn: return
	btn.mouse_entered.connect(func(): AudioManager.play_sfx("ui_hover", 0.2))
	btn.pressed.connect(func(): AudioManager.play_sfx("ui_click"))


========================================
FILE PATH: res://Scripts/MenuArcade.gd
========================================
extends Control

# --- NODES ---
@onready var p1_option = $MarginContainer/VBoxContainer/HBoxContainer/P1_Column/ClassOption
@onready var p1_info = $MarginContainer/VBoxContainer/HBoxContainer/P1_Column/InfoLabel
@onready var p1_portrait = $MarginContainer/VBoxContainer/HBoxContainer/P1_Column/P1_Portrait
@onready var difficulty_option = $MarginContainer/VBoxContainer/HBoxContainer/Settings_Column/DifficultyOption
@onready var maintain_hp_toggle = $MarginContainer/VBoxContainer/HBoxContainer/Settings_Column/MaintainHPToggle
@onready var start_btn = $MarginContainer/VBoxContainer/HBoxContainer/Settings_Column/StartButton

# --- DATA ---
var classes = ["Heavy", "Patient", "Quick", "Technical"]
var base_classes = ["Heavy", "Patient", "Quick", "Technical"]
var presets: Array[PresetCharacter] = []

func _ready():
	_load_presets()
	_setup_options(p1_option)
	_setup_difficulty()
	
	# Connect Signals
	p1_option.item_selected.connect(_on_selection_changed)
	difficulty_option.item_selected.connect(_on_difficulty_changed)
	start_btn.pressed.connect(_on_start_pressed)
	
	# Initial UI State
	p1_option.selected = 0
	_update_info()

func _on_start_pressed():
	# 1. Save Run Modifiers
	RunManager.maintain_hp_enabled = maintain_hp_toggle.button_pressed
	
	# 2. Identify Selection
	var selected_idx = p1_option.selected
	if selected_idx < base_classes.size():
		# Standard Class Start
		var class_enum = selected_idx as CharacterData.ClassType
		RunManager.start_run(class_enum)
	else:
		# Preset Start
		var preset_idx = selected_idx - base_classes.size() - 1
		if preset_idx >= 0 and preset_idx < presets.size():
			var preset = presets[preset_idx]
			RunManager.start_run_from_preset(preset)

func _update_info():
	var idx = p1_option.selected
	# Helper function derived from your old code [cite: 353]
	var temp = _get_character_data_from_selection(idx, "Preview")
	
	var txt = "[b]" + temp.character_name + "[/b]\n"
	txt += "HP: " + str(temp.max_hp) + " | SP: " + str(temp.max_sp) + "\n"
	txt += "[color=yellow]" + temp.passive_desc + "[/color]"
	p1_info.text = txt
	
	if p1_portrait:
		p1_portrait.texture = temp.portrait

# --- REUSED HELPERS (Copied from CharacterSelect.gd) ---

func _load_presets():
	presets.clear()
	var path = "res://Data/Presets/"
	var dir = DirAccess.open(path)
	if dir:
		dir.list_dir_begin()
		var file_name = dir.get_next()
		while file_name != "":
			if not dir.current_is_dir() and (file_name.ends_with(".tres") or file_name.ends_with(".res")):
				var res = load(path + file_name)
				if res is PresetCharacter: presets.append(res)
			file_name = dir.get_next()

func _setup_options(opt: OptionButton):
	opt.clear()
	for c in classes: opt.add_item(c)
	if presets.size() > 0: opt.add_separator("Presets")
	for p in presets: opt.add_item(p.character_name)

func _setup_difficulty():
	difficulty_option.clear()
	difficulty_option.add_item("Very Easy"); difficulty_option.add_item("Easy")
	difficulty_option.add_item("Medium"); difficulty_option.add_item("Hard")
	difficulty_option.selected = 2 # Medium Default

func _on_difficulty_changed(index: int):
	GameManager.ai_difficulty = index as GameManager.Difficulty

func _on_selection_changed(_idx):
	_update_info()

func _get_character_data_from_selection(index: int, p_name: String) -> CharacterData:
	if index < base_classes.size():
		return ClassFactory.create_character(index as CharacterData.ClassType, p_name)
	var preset_idx = index - base_classes.size() - 1
	if preset_idx >= 0: return ClassFactory.create_from_preset(presets[preset_idx])
	return null


========================================
FILE PATH: res://Scripts/MenuQuick.gd
========================================
extends Control

# --- NODES ---
# Added Portrait references
@onready var p1_option = $MarginContainer/HBoxContainer/P1_Column/ClassOption
@onready var p1_portrait = $MarginContainer/HBoxContainer/P1_Column/Portrait # <--- NEW
@onready var p2_option = $MarginContainer/HBoxContainer/P2_Column/ClassOption
@onready var p2_portrait = $MarginContainer/HBoxContainer/P2_Column/Portrait # <--- NEW
@onready var p2_mode_btn = $MarginContainer/HBoxContainer/P2_Column/P2_Mode_Button
@onready var fight_btn = $MarginContainer/HBoxContainer/VS_Column/QuickFightButton

var presets: Array[PresetCharacter] = []
var base_classes = ["Heavy", "Patient", "Quick", "Technical"]

func _ready():
	_load_presets()
	_setup_options(p1_option)
	_setup_options(p2_option)
	
	# Defaults
	p1_option.selected = 0
	p2_option.selected = 1
	
	# --- NEW: Connect Signals to Update Portraits ---
	p1_option.item_selected.connect(func(_idx): _update_portraits())
	p2_option.item_selected.connect(func(_idx): _update_portraits())
	
	# Connections
	fight_btn.pressed.connect(_on_fight_pressed)
	p2_mode_btn.pressed.connect(_on_p2_mode_toggle)
	
	# Sync State
	if GameManager.p2_is_custom == null: GameManager.p2_is_custom = false
	_update_p2_btn_visuals()
	
	# Initial Update
	_update_portraits()

# --- NEW: UPDATE LOGIC ---
func _update_portraits():
	# Update P1
	var p1_data = _get_char(p1_option.selected, "P1")
	if p1_portrait:
		p1_portrait.texture = p1_data.portrait
		
	# Update P2
	var p2_data = _get_char(p2_option.selected, "P2")
	if p2_portrait:
		p2_portrait.texture = p2_data.portrait
		# Flip P2 to face center
		p2_portrait.flip_h = true

func _on_fight_pressed():
	# 1. Random Environment
	var envs = ["Ring", "Dojo", "Street"]
	GameManager.apply_environment_rules(envs.pick_random())
	
	# 2. Setup Data
	var p1 = _get_char(p1_option.selected, "Player 1")
	var p2 = _get_char(p2_option.selected, "Player 2")
	
	GameManager.next_match_p1_data = p1
	GameManager.next_match_p2_data = p2
	
	# 3. Launch
	SceneLoader.change_scene("res://Scenes/VsScreen.tscn")

func _on_p2_mode_toggle():
	GameManager.p2_is_custom = !GameManager.p2_is_custom
	_update_p2_btn_visuals()

func _update_p2_btn_visuals():
	if GameManager.p2_is_custom:
		p2_mode_btn.text = "OPPONENT: PLAYER 2"
		p2_mode_btn.modulate = Color.GREEN
	else:
		p2_mode_btn.text = "OPPONENT: CPU BOT"
		p2_mode_btn.modulate = Color.WHITE

# --- HELPERS ---
func _load_presets():
	presets.clear()
	var path = "res://Data/Presets/"
	var dir = DirAccess.open(path)
	if dir:
		dir.list_dir_begin()
		var file_name = dir.get_next()
		while file_name != "":
			if not dir.current_is_dir() and (file_name.ends_with(".tres") or file_name.ends_with(".res")):
				var res = load(path + file_name)
				if res is PresetCharacter: presets.append(res)
			file_name = dir.get_next()

func _setup_options(opt):
	opt.clear()
	for c in base_classes: opt.add_item(c)
	if presets.size() > 0: opt.add_separator("Presets")
	for p in presets: opt.add_item(p.character_name)

func _get_char(idx, pname):
	if idx < base_classes.size():
		return ClassFactory.create_character(idx as CharacterData.ClassType, pname)
	var preset_idx = idx - base_classes.size() - 1
	if preset_idx >= 0: return ClassFactory.create_from_preset(presets[preset_idx])
	return ClassFactory.create_character(0, "Error")


========================================
FILE PATH: res://Scripts/MenuSettings.gd
========================================
extends Control

#@onready var master_slider = $CenterContainer/VBoxContainer/MasterSlider
#@onready var music_slider = $CenterContainer/VBoxContainer/MusicSlider
#@onready var sfx_slider = $CenterContainer/VBoxContainer/SFXSlider
#@onready var delete_save_btn = $CenterContainer/VBoxContainer/DeleteSaveButton
#
#func _ready():
	## 1. Set initial slider positions based on current volume
	#master_slider.value = db_to_linear(AudioServer.get_bus_volume_db(0))
	#music_slider.value = db_to_linear(AudioServer.get_bus_volume_db(1))
	#sfx_slider.value = db_to_linear(AudioServer.get_bus_volume_db(2))
	#
	## 2. Connect signals
	#master_slider.value_changed.connect(func(v): _set_volume(0, v))
	#music_slider.value_changed.connect(func(v): _set_volume(1, v))
	#sfx_slider.value_changed.connect(func(v): _set_volume(2, v))
	#
	#if delete_save_btn:
		#delete_save_btn.pressed.connect(_on_delete_save_pressed)
#
#func _set_volume(bus_idx: int, value: float):
	## Convert linear slider value (0-1) to Decibels
	#AudioServer.set_bus_volume_db(bus_idx, linear_to_db(value))
	#
	## Optional: Mute if slider is at 0
	#AudioServer.set_bus_mute(bus_idx, value < 0.05)
#
#func _on_delete_save_pressed():
	## Simple safety confirmation could be added here later
	#var dir = DirAccess.open("user://")
	#if dir.file_exists("save_game.json"): # Or whatever you name your save
		#dir.remove("save_game.json")
		#print("Save file deleted.")
		#delete_save_btn.text = "DATA DELETED"
		#delete_save_btn.disabled = true


========================================
FILE PATH: res://Scripts/pausemenu.gd
========================================
extends CanvasLayer

@onready var background = $ColorRect # Assuming your ColorRect is named "ColorRect"

func _ready():
	# Start hidden and unpaused
	visible = false
	
func _input(event):
	if event.is_action_pressed("ui_cancel"): # Default is 'Escape' key
		_toggle_pause()

func _toggle_pause():
	# Flip the paused state
	var new_state = not get_tree().paused
	get_tree().paused = new_state
	visible = new_state

func _on_resume_pressed():
	_toggle_pause()

func _on_main_menu_pressed():
	# 1. Unpause before changing scenes (otherwise the new scene stays frozen!)
	_toggle_pause()
	
	# 2. CLEANUP: Wipe game state so next match starts fresh
	# (Similar to your ActionTree back button logic) [cite: 121]
	GameManager.next_match_p1_data = null
	GameManager.next_match_p2_data = null
	GameManager.p1_data = null
	GameManager.p2_data = null
	
	GameManager.editing_player_index = 1
	GameManager.p2_is_custom = false
	
	# 3. Go to Menu
	SceneLoader.change_scene("res://Scenes/MainMenu.tscn")


========================================
FILE PATH: res://Scripts/PlayerHud.gd
========================================
extends Control

@onready var name_label = $VBoxContainer/NameLabel

# HP References
@onready var hp_bar = $VBoxContainer/HPBarHolder/HPBar
@onready var hp_ghost = $VBoxContainer/HPBarHolder/HPGhost
@onready var hp_text = $VBoxContainer/HPBarHolder/HPBar/HPLabel

# SP References (Updated Paths)
@onready var sp_bar = $VBoxContainer/SPBarHolder/SPBar
@onready var sp_ghost = $VBoxContainer/SPBarHolder/SPGhost # New
@onready var sp_text = $VBoxContainer/SPBarHolder/SPBar/SPLabel

@onready var status_label = $VBoxContainer/StatusLabel
@onready var portrait = get_node_or_null("Portrait")

var original_pos: Vector2 = Vector2.ZERO

func _ready():
	if portrait: original_pos = portrait.position
	
	# Sync Ghosts on load
	if hp_ghost:
		hp_ghost.max_value = hp_bar.max_value
		hp_ghost.value = hp_bar.value
	if sp_ghost:
		sp_ghost.max_value = sp_bar.max_value
		sp_ghost.value = sp_bar.value

func setup(character: CharacterData):
	name_label.text = character.character_name
	
	# HP Setup
	hp_bar.max_value = character.max_hp
	hp_bar.value = character.current_hp
	if hp_ghost:
		hp_ghost.max_value = character.max_hp
		hp_ghost.value = character.current_hp
	hp_text.text = str(character.current_hp) + "/" + str(character.max_hp)
	
	# SP Setup
	sp_bar.max_value = character.max_sp
	sp_bar.value = character.current_sp
	if sp_ghost:
		sp_ghost.max_value = character.max_sp
		sp_ghost.value = character.current_sp
	sp_text.text = str(character.current_sp) + "/" + str(character.max_sp)
	
	if portrait and character.portrait:
		portrait.texture = character.portrait

func configure_visuals(is_player_2: bool):
	# ... (Paste your existing layout code here) ...
	# Just ensuring the fill modes update correctly for the new ghosts
	
	scale = Vector2(1, 1)
	var hud_width = 300 
	var screen_margin = 20
	var gap = 15
	var offset = 150
	$VBoxContainer.custom_minimum_size.x = hud_width
	$VBoxContainer.size.x = hud_width 
	
	var bg = get_node_or_null("Panel") 
	if not bg: bg = get_node_or_null("Background")
	
	# Force Expand
	if hp_bar: hp_bar.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	if hp_ghost: hp_ghost.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	if sp_bar: sp_bar.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	if sp_ghost: sp_ghost.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	
	if is_player_2:
		$VBoxContainer.set_anchors_preset(Control.PRESET_TOP_RIGHT)
		$VBoxContainer.position.x = + screen_margin  - hud_width
		$VBoxContainer.grow_horizontal = Control.GROW_DIRECTION_BEGIN
		if bg:
			bg.set_anchors_preset(Control.PRESET_TOP_RIGHT)
			bg.position = $VBoxContainer.position
			bg.size = $VBoxContainer.size
			bg.grow_horizontal = Control.GROW_DIRECTION_BEGIN
		name_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_RIGHT
		status_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_RIGHT
		
		# Set Fill Modes (Right to Left)
		if hp_bar: hp_bar.fill_mode = TextureProgressBar.FILL_RIGHT_TO_LEFT
		if hp_ghost: hp_ghost.fill_mode = TextureProgressBar.FILL_RIGHT_TO_LEFT
		if sp_bar: sp_bar.fill_mode = TextureProgressBar.FILL_RIGHT_TO_LEFT
		if sp_ghost: sp_ghost.fill_mode = TextureProgressBar.FILL_RIGHT_TO_LEFT
		
		if portrait:
			portrait.scale.x = -1
			portrait.pivot_offset = portrait.size / 2
			portrait.position.x = $VBoxContainer.position.x - portrait.size.x - gap + offset
	else:
		$VBoxContainer.set_anchors_preset(Control.PRESET_TOP_LEFT)
		$VBoxContainer.position.x = screen_margin
		$VBoxContainer.grow_horizontal = Control.GROW_DIRECTION_END
		if bg:
			bg.set_anchors_preset(Control.PRESET_TOP_LEFT)
			bg.position = $VBoxContainer.position
			bg.size = $VBoxContainer.size
			bg.grow_horizontal = Control.GROW_DIRECTION_END
		name_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_LEFT
		status_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_LEFT
		
		# Set Fill Modes (Left to Right)
		if hp_bar: hp_bar.fill_mode = TextureProgressBar.FILL_LEFT_TO_RIGHT
		if hp_ghost: hp_ghost.fill_mode = TextureProgressBar.FILL_LEFT_TO_RIGHT
		if sp_bar: sp_bar.fill_mode = TextureProgressBar.FILL_LEFT_TO_RIGHT
		if sp_ghost: sp_ghost.fill_mode = TextureProgressBar.FILL_LEFT_TO_RIGHT
		
		if portrait:
			portrait.scale.x = 1
			portrait.pivot_offset = portrait.size / 2
			portrait.position.x = $VBoxContainer.position.x + hud_width + gap - offset

	if portrait: original_pos = portrait.position

func update_stats(character: CharacterData, opportunity: int, opening: int, bide_active: bool):
	
	hp_text.text = str(character.current_hp) + "/" + str(character.max_hp)
	sp_text.text = str(character.current_sp) + "/" + str(character.max_sp)
	
	var tween = create_tween()
	tween.set_parallel(true)
	
	# --- HP ANIMATION ---
	tween.tween_property(hp_bar, "value", character.current_hp, 0.2).set_trans(Tween.TRANS_CIRC).set_ease(Tween.EASE_OUT)
	
	if hp_ghost:
		if character.current_hp < hp_ghost.value:
			# Taken Damage: Delay then slide
			var t = create_tween()
			t.tween_interval(0.4)
			t.tween_property(hp_ghost, "value", character.current_hp, 0.6).set_trans(Tween.TRANS_SINE)
		else:
			# Healed: Instant catch up
			hp_ghost.value = character.current_hp

	# --- SP ANIMATION ---
	tween.tween_property(sp_bar, "value", character.current_sp, 0.2).set_trans(Tween.TRANS_CIRC).set_ease(Tween.EASE_OUT)
	
	if sp_ghost:
		if character.current_sp < sp_ghost.value:
			# Spent SP: Delay then slide (Orange Ghost)
			var t = create_tween()
			t.tween_interval(0.4)
			t.tween_property(sp_ghost, "value", character.current_sp, 0.6).set_trans(Tween.TRANS_SINE)
		else:
			# Recovered SP: Instant catch up
			sp_ghost.value = character.current_sp

	# ... (Rest of existing status text logic) ...
	var status_txt = ""
	for s_name in character.statuses:
		status_txt += "[" + s_name.to_upper() + "] "
	
	if opportunity > 0: status_txt += "[OPPORTUNITY] "
	if opening > 0: status_txt += "[OPENING: " + str(opening) + "]"
	if bide_active: status_txt += "[BIDE (+1 DMG)]"
	
	status_label.text = status_txt
	
	if character.statuses.has("Injured"):
		status_label.modulate = Color.ORANGE_RED
	elif bide_active:
		status_label.modulate = Color(0.3, 1.0, 1.0)
	elif opportunity > 0:
		status_label.modulate = Color.YELLOW
	else:
		status_label.modulate = Color.WHITE
		
func play_attack_animation(direction: Vector2):
	if not portrait: return
	var tween = create_tween()
	tween.tween_property(portrait, "position", original_pos - (direction * 0.2), 0.1)
	tween.tween_property(portrait, "position", original_pos + direction, 0.1).set_trans(Tween.TRANS_BACK).set_ease(Tween.EASE_OUT)
	tween.tween_property(portrait, "position", original_pos, 0.2).set_delay(0.1)

func play_hit_animation():
	if not portrait: return
	var tween = create_tween()
	tween.tween_property(portrait, "modulate", Color(3, 0.5, 0.5), 0.05)
	tween.tween_property(portrait, "modulate", Color.WHITE, 0.3)
	
	var shake_offset = Vector2(randf_range(-10, 10), randf_range(-10, 10))
	var t_shake = create_tween()
	t_shake.tween_property(portrait, "position", original_pos + shake_offset, 0.05)
	t_shake.tween_property(portrait, "position", original_pos - shake_offset, 0.05)
	t_shake.tween_property(portrait, "position", original_pos, 0.05)


========================================
FILE PATH: res://Scripts/Resources/ActionData.gd
========================================
class_name ActionData
extends Resource

# Enums allow for dropdown selection in the Inspector, preventing typos.
enum Type { OFFENCE, DEFENCE }

# --- VISUALS ---
@export_group("Visuals")
@export var id: String             # Unique ID (e.g., "basic_strike_01")
@export var display_name: String   # The name displayed to the player
@export var icon: Texture2D        # The card art/icon
@export_multiline var description: String # Tooltip description of effects

# --- CORE STATS ---
@export_group("Core Stats")
@export var type: Type             # OFFENCE (Red) or DEFENCE (Blue)
@export var cost: int = 0          # Stamina (SP) cost to play this card
@export var damage: int = 0        # Base damage dealt to opponent
@export var momentum_gain: int = 0 # Amount this card pushes the momentum tracker

# --- COMBAT VALUES ---
@export_group("Combat Values")
@export var block_value: int = 0   # Reduces incoming Damage
@export var dodge_value: int = 0   # Reduces incoming Damage (thematically distinct)
@export var heal_value: int = 0    # Restores HP
@export var recover_value: int = 0 # Restores SP
@export var fall_back_value: int = 0 # Pushes momentum backwards (counteracts gain)
@export var counter_value: int = 0 # Required "Opening" level on opponent to play this
@export var tiring: int = 0        # Drains opponent's SP on hit

# --- SPECIAL BOOLEANS ---
@export_group("Special Mechanics")
@export var is_opener: bool = false      # Can be played at 0 Momentum or start of combo
@export var is_super: bool = false       # Requires specific Momentum; 1 use per match
@export var guard_break: bool = false    # Ignores opponent's Block/Dodge
@export var feint: bool = false          # Triggers Secondary Selection phase
#@export var injure: bool = false         # Applies "Injured" status (DoT)
@export var sweep: bool = false          # (Mass combat flag - unused in 1v1)
@export var retaliate: bool = false      # Reflects damage back to attacker
@export var reversal: bool = false       # Seizes initiative if momentum moves closer
@export var is_parry: bool = false       # Steals momentum; grants Immunity if successful

# --- NEW: SCALABLE STATUS PAYLOAD ---
# Editor Usage: Add Element -> Key: "name" Value: "Poison", Key: "amount" Value: 3
@export var statuses_to_apply: Array[Dictionary] = []

# --- ADVANCED LOGIC ---
@export_group("Advanced Logic")
@export var multi_limit: int = 0         # Limits opponent's max cost next turn
@export var repeat_count: int = 1        # Number of times the effect loop runs (e.g., Flurry)
@export var create_opening: int = 0      # Sets opponent's Opening Stat (enables Counters)
@export var opportunity: int = 0         # Reduces cost/Increases momentum next turn


========================================
FILE PATH: res://Scripts/Resources/CharacterData.gd
========================================
class_name CharacterData
extends Resource

#region vars

#To add a completely new class identity, you still need to do two small code updates:
#
#Add MAGE to the ClassType Enum.
#
#Add the if class == MAGE: logic in GameManager for their specific mechanic.

enum ClassType { HEAVY, PATIENT, QUICK, TECHNICAL }

# --- NEW: AI PERSONALITY TYPES ---
enum AIArchetype { BALANCED, AGGRESSIVE, DEFENSIVE, TRICKSTER }
@export var ai_archetype: AIArchetype = AIArchetype.BALANCED 
# ---------------------------------

# --- STATIC DATA ---
@export_group("Identity")
@export var character_name: String
@export var portrait: Texture2D
@export var class_type: ClassType

@export_group("Stats")
@export var max_hp: int = 5     
@export var max_sp: int = 4      
@export var speed: int = 1       

@export_group("Progression")
@export var deck: Array[ActionData]  # The Active 8 Cards
@export var unlocked_actions: Array[ActionData] = [] # The Full Library
@export var equipment: Array[EquipmentData] = [] # <--- NEW: The items you carry

@export_group("Passive")
@export_multiline var passive_desc: String 

# --- RUNTIME STATE ---
@export_group("Runtime State")
var current_hp: int
var current_sp: int
var has_used_super: bool = false 
var combo_action_count: int = 0 # Track for Relentless passive
var patient_buff_active: bool = false #Tracks the +1 Damage Buff

# --- NEW: STATUS DICTIONARY ---
# Format: { "Injured": 1, "Poison": 3, "Stunned": 1 }
var statuses: Dictionary = {}


#endregion

# --- LOGIC ---

func reset_stats(maintain_hp: bool = false):
	# Only reset HP to max if we are NOT maintaining it
	if not maintain_hp:
		current_hp = max_hp
		
	# SP and Statuses always reset per fight
	current_sp = max_sp
	has_used_super = false
	combo_action_count = 0
	patient_buff_active = false
	statuses.clear()
# Call this when the player "Learns" a new card to apply Class Stat Growth
func unlock_action(new_action: ActionData):
	if new_action in deck: return
	
	deck.append(new_action)
	_apply_level_up_stats(new_action.type)

func _apply_level_up_stats(card_type):
	# Rules derived from PDF v0.2 Class Section
	match class_type:
		ClassType.HEAVY:
			if card_type == ActionData.Type.OFFENCE: max_sp += 1
			elif card_type == ActionData.Type.DEFENCE: max_hp += 2
			
		ClassType.PATIENT:
			if card_type == ActionData.Type.OFFENCE: max_hp += 1
			elif card_type == ActionData.Type.DEFENCE: 
				max_hp += 1
				max_sp += 1
				
		ClassType.QUICK:
			if card_type == ActionData.Type.OFFENCE: max_hp += 1
			elif card_type == ActionData.Type.DEFENCE: max_sp += 2
			
		ClassType.TECHNICAL:
			if card_type == ActionData.Type.OFFENCE: 
				max_hp += 1
				max_sp += 1
			elif card_type == ActionData.Type.DEFENCE: max_sp += 1
			
	# Heal to full on level up? Optional, but usually good.
	current_hp = max_hp
	current_sp = max_sp
	print("Level Up! New Stats - HP: " + str(max_hp) + " | SP: " + str(max_sp))


========================================
FILE PATH: res://Scripts/Resources/ClassDefinition.gd
========================================
extends Resource
class_name ClassDefinition

@export_group("Identity")
@export var class_named: String = "New Class"
@export var class_type: CharacterData.ClassType # Keep enum for safety, or switch to String ID
@export var portrait: Texture2D
@export_multiline var passive_description: String

@export_group("Base Stats")
@export var base_hp: int = 5
@export var base_sp: int = 4
@export var base_speed: int = 1

@export_group("Growth Rules")
# How much stats increase per card type
@export var offence_hp_growth: int = 0
@export var offence_sp_growth: int = 0
@export var defence_hp_growth: int = 0
@export var defence_sp_growth: int = 0

@export_group("Progression")
@export var starting_deck: Array[ActionData] = []
@export var skill_tree_root_id: int = 0


========================================
FILE PATH: res://Scripts/Resources/DialogueManager.gd
========================================
extends Node

# --- DATA STRUCTURE ---
# Key: ClassType (Who is speaking?)
# Value: Dictionary of Contexts -> Array of Strings
var lines = {
	CharacterData.ClassType.HEAVY: {
		"INTRO_GENERIC": ["I'm gonna break you in half!", "Don't cry when this is over.", "Hmph. Tiny."],
		"INTRO_VS_QUICK": ["Stop hopping around and FIGHT!", "I'll swat you like a fly."],
		"WIN_OFFENCE": ["CRUSHED!", "Too weak!", "Boom!"],
		"WIN_DEFENCE": ["Is that it?", "Tickles.", "My turn."],
		"HURT_HEAVY": ["GAAH!", "You'll pay for that...", "Finally, a challenge!"],
		"USE_SUPER": ["GAME OVER!", "GOODNIGHT!"],
		"LOW_HP": ["I... am not... done...", "Just... a scratch..."]
	},
	CharacterData.ClassType.QUICK: {
		"INTRO_GENERIC": ["Too slow!", "Catch me if you can!", "This will be over in a second."],
		"INTRO_VS_HEAVY": ["Big target. Easy target.", "You'll never hit me, big guy!"],
		"WIN_OFFENCE": ["Too slow!", "Keep up!", "Gotcha!"],
		"WIN_DEFENCE": ["Missed me!", "Too obvious.", "Nope!"],
		"HURT_HEAVY": ["Oof! Okay...", "Hey! Watch the face!", "That... actually hurt."],
		"USE_SUPER": ["MAXIMUM SPEED!", "LIGHTSPEED!"],
		"LOW_HP": ["Running... on fumes...", "Can't... stop..."]
	},
	CharacterData.ClassType.TECHNICAL: {
		"INTRO_GENERIC": ["I've already calculated your defeat.", "Your stance is full of openings.", "Let's test my theory."],
		"INTRO_VS_PATIENT": ["Stalling won't save you.", "I know exactly what you're waiting for."],
		"WIN_OFFENCE": ["Calculated.", "Precision strikes.", "Dissected."],
		"WIN_DEFENCE": ["Predictable.", "As expected.", "Flawed technique."],
		"HURT_HEAVY": ["Miscalculation...", "An error in judgment.", "Critical damage taken."],
		"USE_SUPER": ["CHECKMATE.", "SOLUTION FOUND."],
		"LOW_HP": ["System... failing...", "Impossible..."]
	},
	CharacterData.ClassType.PATIENT: {
		"INTRO_GENERIC": ["Patience is a weapon.", "I can wait all day.", "Your anger makes you sloppy."],
		"INTRO_VS_TECHNICAL": ["Analyze all you want. I'm not moving.", "Overthinking creates doubt."],
		"WIN_OFFENCE": ["An opening.", "Now.", "Exposed."],
		"WIN_DEFENCE": ["Denied.", "Wasted effort.", "Not yet."],
		"HURT_HEAVY": ["A solid hit...", "I underestimated you.", "Focus..."],
		"USE_SUPER": ["THE WAIT IS OVER.", "STRIKE TRUE."],
		"LOW_HP": ["Breathing... difficult...", "Must... stay... calm..."]
	}
}

# --- FUNCTIONS ---

# Returns a dictionary { "p1": "Line", "p2": "Line" }
func get_intro_banter(p1_type, p2_type) -> Dictionary:
	var p1_line = _get_line(p1_type, "INTRO_GENERIC")
	var p2_line = _get_line(p2_type, "INTRO_GENERIC")
	
	# Check for specific match-up lines (P1 vs P2)
	var p1_specific_key = "INTRO_VS_" + ClassFactory.class_enum_to_string(p2_type).to_upper()
	if lines.has(p1_type) and lines[p1_type].has(p1_specific_key):
		p1_line = lines[p1_type][p1_specific_key].pick_random()
		
	# Check for specific match-up lines (P2 vs P1)
	var p2_specific_key = "INTRO_VS_" + ClassFactory.class_enum_to_string(p1_type).to_upper()
	if lines.has(p2_type) and lines[p2_type].has(p2_specific_key):
		p2_line = lines[p2_type][p2_specific_key].pick_random()
		
	return { "p1":"'" +  p1_line + "'", "p2":"'" +  p2_line + "'" }

func get_reaction(class_type, context: String) -> String:
	return _get_line(class_type, context)

func _get_line(class_type, key: String) -> String:
	if not lines.has(class_type): return "..."
	if not lines[class_type].has(key): return "..."
	return lines[class_type][key].pick_random()


========================================
FILE PATH: res://Scripts/Resources/EquipmentData.gd
========================================
class_name EquipmentData
extends Resource

@export_group("Visuals")
@export var display_name: String
@export_multiline var description: String
@export var icon: Texture2D

@export_group("Stat Modifiers")
@export var max_hp_bonus: int = 0
@export var max_sp_bonus: int = 0
@export var starting_sp_bonus: int = 0 # Gives extra SP at the start of a fight

@export_group("Combat Modifiers")
@export var wall_crush_damage_bonus: int = 0


========================================
FILE PATH: res://Scripts/Resources/GameManager.gd
========================================
extends Node

#region vars
const KEYWORD_DEFS = {
	"Block": "Reduce incoming damage by X",
	"Cost": "lose X stamina",
	"Counter": "You must have used an action with Create Opening X or higher in the previous clash",
	"Create Opening": "Your opponents next action cannot have a Cost trait higher than X",
	"Damage": "Reduce your opponents health by X",
	"Defence": "Can only be used on the defensive. This action gains the Recover 1 trait.",
	"Feint": "In addition to the actions listed traits, it gains all the traits of another action that you can use. That action can be chosen after actions are revealed",
	"Dodge": "You ignore the effects of your opponents action if its total stamina cost is X or below",
	"Fall Back": "Lose X momentum",
	"Guard Break": "Ignore the Block X trait of your opponents action",
	"Heal": "Gain X HP",
	"Injure": "Your opponent must lose 1 HP every clash after this until you use an action with the Recover X, Heal X or Fall Back X traits, or the combat ends",
	"Momentum": "Gain X momentum",
	"Multi": "After this action, you may use any other action that has a Cost trait of X or below, and that does not have the multi X trait. This action interacts with your opponents previous action. If your opponents action would end your combo, you do not get to use this trait. In addition, moves with this trait can be used to start a combo",
	"Offence": "Can only be used on the offensive. If you are reduced to 0SP, your combo ends",
	"Opener": "Only actions with this trait can be used to start a combo",
	"Opportunity": "Increase your next actions momentum by X, and reduce its stamina cost by X",
	"Parry": "Your action steals the Momentum X trait of your opponents action. If this causes the momentum tracker to move in your direction, your opponents action has no affect on you, and your opponents next action must have the Opener trait",
	"Recover": "Gain X stamina",
	"Repeat": "After this action, use the same action again, ignoring the Repeat X trait. This must continue X times. This action interacts with your opponents chosen action as normal",
	"Retaliate": "Your opponent takes the same damage as they dealt to you in the previous clash",
	"Reversal": "If the momentum tracker moves closer to your side from this clash, the current combo ends and you take the offence, even if you do not have the momentum advantage. This applies even in the inital clash",
	"Super": "This action can only be used when the momentum tracker has reached the end of your side. You can only use an action with this trait once per combat",
	"Sweep": "This action affects all opponents you are in combat with",
	"Tiring": "Cause the opponent to lose X Stamina"
}

# --- SIGNALS ---
signal state_changed(new_state)
signal clash_resolved(winner_id, log_text)
signal combat_log_updated(text)
signal game_over(winner_id)
signal damage_dealt(target_id: int, amount: int, is_blocked: bool)
signal healing_received(target_id: int, amount: int)
signal status_applied(target_id: int, status_name: String)
signal request_clash_animation(p1_card, p2_card)
signal clash_animation_finished
signal wall_crush_occurred(player_id, damage_amount)


# --- CONFIGURATION ---
var TOTAL_MOMENTUM_SLOTS: int = 8 
var current_environment_name: String = "Dojo"
var environment_backgrounds: Dictionary = {}
# --- DYNAMIC CALCULATIONS ---
var MOMENTUM_P1_MAX: int = 4
var MOMENTUM_P2_START: int = 5

# --- STATE MACHINE ---
enum State { SETUP, SELECTION, REVEAL, FEINT_CHECK, RESOLUTION, POST_CLASH, GAME_OVER }
var current_state = State.SETUP
var temp_p1_class_selection: int = 0
var temp_p2_class_selection: int = 0 
var editing_player_index: int = 1    
var p2_is_custom: bool = false       
enum Difficulty { VERY_EASY, EASY, MEDIUM, HARD }
var ai_difficulty: Difficulty = Difficulty.MEDIUM 
var attacker_override: int = 0 

# --- PERSISTENT GAME SETUP ---
var next_match_p1_data: CharacterData
var next_match_p2_data: CharacterData

# --- CORE DATA ---
var p1_data: CharacterData
var p2_data: CharacterData
var priority_player: int = 1 
var momentum: int = 0 
var current_combo_attacker: int = 0

# --- TURN CONSTRAINTS ---
var p1_cost_limit: int = 99; var p2_cost_limit: int = 99
var p1_opening_stat: int = 0; var p2_opening_stat: int = 0
var p1_opportunity_stat: int = 0; var p2_opportunity_stat: int = 0
var p1_must_opener: bool = false; var p2_must_opener: bool = false

## --- STATUS EFFECTS ---
#var p1_is_injured: bool = false
#var p2_is_injured: bool = false

# --- TURN STATE ---
var p1_action_queue: ActionData
var p2_action_queue: ActionData
var p1_locked_card: ActionData = null
var p2_locked_card: ActionData = null

# --- FEINT HELPERS ---
var p1_pending_feint: bool = false
var p2_pending_feint: bool = false

# --- PASSIVES ---
var p1_rage_active: bool = false
var p2_rage_active: bool = false
var p1_keep_up_active: bool = false
var p2_keep_up_active: bool = false

var temp_p1_name: String = ""
var temp_p2_name: String = ""
var temp_p1_preset: Resource = null
var temp_p2_preset: Resource = null
#endregion

# ==============================================================================
# INITIALIZATION
# ==============================================================================

func _ready():
	
	_load_backgrounds()
	
	MOMENTUM_P1_MAX = int(TOTAL_MOMENTUM_SLOTS / 2.0)
	MOMENTUM_P2_START = MOMENTUM_P1_MAX + 1
	
	print("--- GAME MANAGER READY ---")
	print("Momentum Config: Total=", TOTAL_MOMENTUM_SLOTS, " | P1_Max=", MOMENTUM_P1_MAX, " | P2_Start=", MOMENTUM_P2_START)
	
	priority_player = 1
	momentum = 0

func start_combat(p1: CharacterData, p2: CharacterData):
	p1_data = p1
	p2_data = p2
	reset_combat()

func reset_combat():
	# --- FIX: Check if P1 should maintain HP ---
	var p1_maintain = RunManager.is_arcade_mode and RunManager.maintain_hp_enabled
	p1_data.reset_stats(p1_maintain) 
	
	# P2 (The Enemy) always resets to full
	p2_data.reset_stats(false)
	# -------------------------------------------
	
	# --- FIX: INJECT EVENT STATUSES AFTER RESET ---
	if RunManager.is_arcade_mode:
		for s in RunManager.next_fight_statuses:
			p1_data.statuses[s] = 1
		RunManager.next_fight_statuses.clear() # Clear so it doesn't happen next fight
	# ----------------------------------------------
	
	momentum = 0 
	current_combo_attacker = 0
	p1_locked_card = null; p2_locked_card = null
	
	p1_cost_limit = 99; p2_cost_limit = 99
	p1_opening_stat = 0; p2_opening_stat = 0
	p1_opportunity_stat = 0; p2_opportunity_stat = 0
	p1_must_opener = false; p2_must_opener = false
	# REMOVED: p1_is_injured = false
	# REMOVED: p2_is_injured = false
	p1_pending_feint = false; p2_pending_feint = false
	
	p1_rage_active = false; p2_rage_active = false
	p1_keep_up_active = false; p2_keep_up_active = false
	
	# --- NEW: EQUIPMENT START-OF-COMBAT EFFECTS ---
	for item in p1_data.equipment:
		# FIX: Removed min() clamp so players can start with MORE than their max SP
		p1_data.current_sp += item.starting_sp_bonus
		
	for item in p2_data.equipment:
		p2_data.current_sp += item.starting_sp_bonus
	# ----------------------------------------------------
	
	if p1_data.speed > p2_data.speed: priority_player = 1
	elif p2_data.speed > p1_data.speed: priority_player = 2
	else: priority_player = randi_range(1, 2)
		
	print("\n>>> COMBAT RESET! Starting from Initial Clash (Neutral) <<<")
	change_state(State.SELECTION)

func get_attacker() -> int:
	if current_combo_attacker != 0: return current_combo_attacker
	if attacker_override != 0: return attacker_override
	if momentum == 0: return 0 
	return 1 if momentum <= MOMENTUM_P1_MAX else 2

# ==============================================================================
# STATE MACHINE
# ==============================================================================

func change_state(new_state: State):
	current_state = new_state
	emit_signal("state_changed", current_state)
	
	match current_state:
		State.SELECTION:
			if p1_locked_card: player_select_action(1, p1_locked_card)
			if p2_locked_card: player_select_action(2, p2_locked_card)
		State.REVEAL:
			_enter_reveal_phase()
		State.FEINT_CHECK:
			pass 
		State.RESOLUTION:
			resolve_clash()

func player_select_action(player_id: int, action: ActionData, extra_data: Dictionary = {}):
	# 1. Process the Action based on Technique
	var final_action = action
	var tech_idx = extra_data.get("technique", 0)
	
	# Only modify if a technique was actually selected AND action is not null (Skip)
	if action != null and tech_idx > 0:
		final_action = action.duplicate() 
		final_action.cost += 1 
		
		match tech_idx:
			1: # Opener
				if final_action.type == ActionData.Type.OFFENCE:
					final_action.is_opener = true
					final_action.display_name += "+" 
			2: # Tiring
				final_action.tiring += 1
				final_action.display_name += "+"
			3: # Momentum
				final_action.momentum_gain += 1
				final_action.display_name += "+"
	
	# 2. Standard Logic
	if player_id == 1:
		p1_action_queue = final_action
		p1_rage_active = extra_data.get("rage", false)
		p1_keep_up_active = extra_data.get("keep_up", false)
	else:
		p2_action_queue = final_action
		p2_rage_active = extra_data.get("rage", false)
		p2_keep_up_active = extra_data.get("keep_up", false)
		
	if current_state == State.SELECTION:
		if p1_action_queue and p2_action_queue:
			change_state(State.REVEAL)
	elif current_state == State.FEINT_CHECK:
		_handle_feint_selection(player_id, final_action)

# ==============================================================================
# FEINT MECHANICS
# ==============================================================================

func _enter_reveal_phase():
	emit_signal("combat_log_updated", "\nREVEAL: P1 chose " + p1_action_queue.display_name + " | P2 chose " + p2_action_queue.display_name)
	emit_signal("request_clash_animation", p1_action_queue, p2_action_queue)
	await self.clash_animation_finished
	
	p1_pending_feint = p1_action_queue.feint
	p2_pending_feint = p2_action_queue.feint

	if p1_pending_feint or p2_pending_feint:
		change_state(State.FEINT_CHECK)
	else:
		change_state(State.RESOLUTION)

func _handle_feint_selection(player_id: int, secondary_action: ActionData):
	if secondary_action == null:
		emit_signal("combat_log_updated", "P" + str(player_id) + " skips Feint combination.")
		_clear_feint_flag(player_id)
		_check_feint_completion()
		return

	var base_card = p1_action_queue if player_id == 1 else p2_action_queue
	var character = p1_data if player_id == 1 else p2_data
	
	var total_cost = base_card.cost + secondary_action.cost
	var opp_val = _get_opportunity_value(player_id)
	var effective_total = max(0, total_cost - opp_val)
	
	var combined_card = _combine_actions(base_card, secondary_action)
	var total_reps = max(1, combined_card.repeat_count)
	var total_required = effective_total * total_reps
	
	var can_afford = false
	if character.current_sp >= total_required:
		can_afford = true
	elif character.class_type == CharacterData.ClassType.HEAVY and (character.current_sp + character.current_hp) > total_required:
		can_afford = true 
		
	if can_afford:
		emit_signal("combat_log_updated", "P" + str(player_id) + " Feint Successful! Combined into: " + combined_card.display_name)
		if player_id == 1: p1_action_queue = combined_card
		else: p2_action_queue = combined_card
	else:
		emit_signal("combat_log_updated", "P" + str(player_id) + " not enough SP for Feint. Action applies normally.")
	
	_clear_feint_flag(player_id)
	_check_feint_completion()

func _clear_feint_flag(player_id):
	if player_id == 1: p1_pending_feint = false
	else: p2_pending_feint = false

func _check_feint_completion():
	if not p1_pending_feint and not p2_pending_feint:
		change_state(State.RESOLUTION)

func _combine_actions(base: ActionData, sec: ActionData) -> ActionData:
	var new_card = base.duplicate()
	new_card.display_name = base.display_name + " + " + sec.display_name
	
	new_card.cost += sec.cost
	new_card.damage += sec.damage
	new_card.block_value += sec.block_value
	new_card.dodge_value += sec.dodge_value
	new_card.momentum_gain += sec.momentum_gain
	new_card.heal_value += sec.heal_value
	new_card.recover_value += sec.recover_value
	new_card.fall_back_value += sec.fall_back_value
	new_card.tiring += sec.tiring
	new_card.create_opening += sec.create_opening
	new_card.multi_limit += sec.multi_limit
	new_card.opportunity += sec.opportunity
	
	new_card.counter_value = max(new_card.counter_value, sec.counter_value) 
	new_card.repeat_count = max(new_card.repeat_count, sec.repeat_count)
	
	if sec.guard_break: new_card.guard_break = true
	if sec.injure: new_card.injure = true
	if sec.retaliate: new_card.retaliate = true
	if sec.is_parry: new_card.is_parry = true
	if sec.is_super: new_card.is_super = true
	if sec.is_opener: new_card.is_opener = true
	
	new_card.feint = false 
	return new_card

# ==============================================================================
# RESOLUTION LOGIC
# ==============================================================================

func resolve_clash():
	attacker_override = 0
	
	# Duplicate to ensure we don't modify the original resource
	p1_action_queue = p1_action_queue.duplicate()
	p2_action_queue = p2_action_queue.duplicate()
	
	_handle_patient_passive(1, p1_action_queue)
	_handle_patient_passive(2, p2_action_queue)
	
	var winner_id = 0
	
	if p1_action_queue.type == ActionData.Type.OFFENCE and p2_action_queue.type == ActionData.Type.DEFENCE: winner_id = 1
	elif p2_action_queue.type == ActionData.Type.OFFENCE and p1_action_queue.type == ActionData.Type.DEFENCE: winner_id = 2
	elif p1_action_queue.cost < p2_action_queue.cost: winner_id = 1
	elif p2_action_queue.cost < p1_action_queue.cost: winner_id = 2
	else:
		emit_signal("combat_log_updated", "Tie! Priority Token Used.")
		winner_id = priority_player
		swap_priority()

	emit_signal("clash_resolved", winner_id, p1_action_queue, p2_action_queue, "Clash Winner: P" + str(winner_id))
	
	var is_initial_clash = (momentum == 0)
	
	# --- SMART COMBO RESET ---
	# If P1 wins with Offence...
	if winner_id == 1 and p1_action_queue.type == ActionData.Type.OFFENCE:
		# Check if they were ALREADY comboing. If not (e.g., previous turn was neutral or 0 SP break), start at 1.
		if current_combo_attacker != 1: p1_data.combo_action_count = 1
		else: p1_data.combo_action_count += 1
	else:
		p1_data.combo_action_count = 0

	# Same for P2
	if winner_id == 2 and p2_action_queue.type == ActionData.Type.OFFENCE:
		if current_combo_attacker != 2: p2_data.combo_action_count = 1
		else: p2_data.combo_action_count += 1
	else:
		p2_data.combo_action_count = 0
	# ------------------------------
	
	# --- PHASE 0: PAY COSTS ---
	var p1_started_injured = has_status(1, "Injured")
	var p2_started_injured = has_status(2, "Injured")
	
	var p1_active = _pay_cost(1, p1_action_queue)
	var p2_active = _pay_cost(2, p2_action_queue)

	if p1_active and p1_action_queue.is_super:
		p1_data.has_used_super = true
		emit_signal("combat_log_updated", ">> P1 unleashes their Ultimate Art!")
	if p2_active and p2_action_queue.is_super:
		p2_data.has_used_super = true
		emit_signal("combat_log_updated", ">> P2 unleashes their Ultimate Art!")

	# --- PHASE 1: SELF EFFECTS ---
	if p1_active: _apply_phase_1_self_effects(1, p1_action_queue)
	if p2_active: _apply_phase_1_self_effects(2, p2_action_queue)

	# --- MOMENTUM CALCULATION ---
	
	# A. Dodge Checks
	var p1_is_dodged = false; var p2_is_dodged = false
	var p1_total_cost = p1_action_queue.cost * max(1, p1_action_queue.repeat_count)
	var p2_total_cost = p2_action_queue.cost * max(1, p2_action_queue.repeat_count)
	
	if p2_active and p2_action_queue.dodge_value > 0 and p2_action_queue.dodge_value >= p1_total_cost: p1_is_dodged = true
	if p1_active and p1_action_queue.dodge_value > 0 and p1_action_queue.dodge_value >= p2_total_cost: p2_is_dodged = true
	
	# B. Push/Pull Base Values
	var p1_parries = (p1_active and p1_action_queue.is_parry)
	var p2_parries = (p2_active and p2_action_queue.is_parry)
	
	var p1_single_gain = p1_action_queue.momentum_gain + _get_opportunity_value(1)
	var p2_single_gain = p2_action_queue.momentum_gain + _get_opportunity_value(2)
	
	var p1_total_gain = _calculate_projected_momentum(1, p1_action_queue, p1_active)
	var p2_total_gain = _calculate_projected_momentum(2, p2_action_queue, p2_active)
	
	var p1_stolen = p2_single_gain if p1_parries else 0
	var p2_stolen = p1_single_gain if p2_parries else 0
	
	var p1_reps = max(1, p1_action_queue.repeat_count) if p1_active else 1
	var p2_reps = max(1, p2_action_queue.repeat_count) if p2_active else 1
	
	var p1_fb = (p1_action_queue.fall_back_value * p1_reps) if p1_active else 0
	var p2_fb = (p2_action_queue.fall_back_value * p2_reps) if p2_active else 0
	
	# --- WALL CRUSH CHECK ---
	if p1_fb > 0 and momentum >= TOTAL_MOMENTUM_SLOTS:
		_apply_wall_crush(1, p1_fb)
		p1_fb = 0 
		
	if p2_fb > 0 and momentum <= 1:
		_apply_wall_crush(2, p2_fb)
		p2_fb = 0 
	# ------------------------------
	
	# --- STRICT PARRY SUCCESS CHECK ---
	# Parry only triggers if (My Gain + Stolen Gain) is strictly greater than My Fall Back.
	var p1_net_gain = p1_total_gain + p1_stolen - p1_fb
	var p2_net_gain = p2_total_gain + p2_stolen - p2_fb
	
	var p1_parry_success = (p1_parries and p1_net_gain > 0)
	var p2_parry_success = (p2_parries and p2_net_gain > 0)
	# ---------------------------------------

	# Calculate the final combined movement for the UI tracker
	var p1_contribution = p1_total_gain
	if p2_parries: p1_contribution -= p1_single_gain
	if p1_is_dodged: p1_contribution = 0
	
	var p2_contribution = p2_total_gain
	if p1_parries: p2_contribution -= p2_single_gain
	if p2_is_dodged: p2_contribution = 0
	
	var p1_final_push = p1_contribution + p1_stolen
	var p2_final_push = p2_contribution + p2_stolen
	
	var delta = (-p1_final_push + p1_fb) + (p2_final_push - p2_fb)
	
	# --- PHASE 2: COMBAT EFFECTS ---
	var p1_results = { "fatal": false, "opening": 0, "opportunity": 0 }
	var p2_results = { "fatal": false, "opening": 0, "opportunity": 0 }
	
	var p2_immune_or_dodged = p2_parry_success or p1_is_dodged
	var p1_immune_or_dodged = p1_parry_success or p2_is_dodged
	
	if p1_active: p1_results = _apply_phase_2_combat_effects(1, 2, p1_action_queue, p2_action_queue, p2_immune_or_dodged)
	if p2_active: p2_results = _apply_phase_2_combat_effects(2, 1, p2_action_queue, p1_action_queue, p1_immune_or_dodged)
	
	_update_turn_constraints(p1_results, p2_results, p1_action_queue, p2_action_queue, p1_parry_success, p2_parry_success)
	
	if p1_results["fatal"] or p2_results["fatal"]:
		_handle_death(winner_id)
		return 
	
	# --- PHASE 3: APPLY MOMENTUM & REVERSAL ---
	var p1_reversed = (p1_active and p1_action_queue.reversal and delta < 0)
	var p2_reversed = (p2_active and p2_action_queue.reversal and delta > 0)

	if is_initial_clash:
		momentum = MOMENTUM_P1_MAX if winner_id == 1 else MOMENTUM_P2_START
		print("DEBUG: Initial Clash Winner: P", winner_id, " | Set Mom: ", momentum)
		
		if p1_reversed:
			attacker_override = 1
			emit_signal("combat_log_updated", ">> P1 Reverses! Seizing Offence.")
		elif p2_reversed:
			attacker_override = 2
			emit_signal("combat_log_updated", ">> P2 Reverses! Seizing Offence.")
			
	else:
		momentum = clamp_momentum(momentum + delta)
		
		if p1_reversed:
			attacker_override = 1
			emit_signal("combat_log_updated", ">> P1 REVERSAL SUCCESSFUL!")
		elif p2_reversed:
			attacker_override = 2
			emit_signal("combat_log_updated", ">> P2 REVERSAL SUCCESSFUL!")

	# --- CLEANUP ---
	_handle_status_damage(winner_id, p1_started_injured, p2_started_injured)
	_check_reversal_state() 
	_handle_locks(winner_id)

	p1_action_queue = null
	p2_action_queue = null
	
	if p1_data.current_hp <= 0 or p2_data.current_hp <= 0:
		_handle_death(winner_id)
		return

	change_state(State.POST_CLASH)
	change_state(State.SELECTION)

# ==============================================================================
# PHASE IMPLEMENTATIONS
# ==============================================================================

func _apply_wall_crush(player_id: int, amount: int):
	var character = p1_data if player_id == 1 else p2_data
	
	# --- NEW: CHECK IF ATTACKER HAS SPIKED CLEATS ---
	var attacker_data = p2_data if player_id == 1 else p1_data
	var final_amount = amount
	for item in attacker_data.equipment:
		final_amount += item.wall_crush_damage_bonus
	# ------------------------------------------------
	
	# --- NEW: EMIT SIGNAL ---
	emit_signal("wall_crush_occurred", player_id, final_amount)
	# ------------------------
	
	emit_signal("combat_log_updated", ">> P" + str(player_id) + " CRUSHED against the wall!")
	
	if character.current_sp >= final_amount:
		character.current_sp -= final_amount
		emit_signal("combat_log_updated", "   Lost " + str(final_amount) + " SP to hold ground.")
	else:
		var sp_paid = character.current_sp
		var hp_damage = final_amount - sp_paid
		
		character.current_sp = 0
		character.current_hp -= hp_damage
		
		emit_signal("combat_log_updated", "   Lost " + str(sp_paid) + " SP and took " + str(hp_damage) + " HP DAMAGE!")
		emit_signal("damage_dealt", player_id, hp_damage, false)

func _apply_phase_1_self_effects(owner_id: int, my_card: ActionData):
	var character = p1_data if owner_id == 1 else p2_data
	var total_hits = max(1, my_card.repeat_count)
	
	if character.class_type == CharacterData.ClassType.QUICK:
		if character.combo_action_count > 0 and (character.combo_action_count % 3 == 0):
			character.current_sp = min(character.current_sp + 1, character.max_sp)
			emit_signal("combat_log_updated", ">> Relentless! P" + str(owner_id) + " recovers 1 SP.")
	
	for i in range(total_hits):
		var actual_recover = my_card.recover_value
		if my_card.type == ActionData.Type.DEFENCE: actual_recover += 1
		
		if actual_recover > 0: 
			character.current_sp = min(character.current_sp + actual_recover, character.max_sp)
			
		if my_card.heal_value > 0: 
			character.current_hp = min(character.current_hp + my_card.heal_value, character.max_hp)
			emit_signal("healing_received", owner_id, my_card.heal_value)

		if my_card.heal_value > 0 or my_card.fall_back_value > 0:
			if has_status(owner_id, "Injured"):
				remove_status(owner_id, "Injured")
				emit_signal("combat_log_updated", ">> P" + str(owner_id) + " cures Injury!")

func _apply_phase_2_combat_effects(owner_id: int, target_id: int, my_card: ActionData, enemy_card: ActionData, target_is_immune: bool) -> Dictionary:
	var character = p1_data if owner_id == 1 else p2_data
	var target = p2_data if owner_id == 1 else p1_data
	var result = { "fatal": false, "opening": 0, "opportunity": 0 }
	
	if target_is_immune:
		emit_signal("combat_log_updated", "P" + str(owner_id) + " attack NULLIFIED (Dodge/Parry)!")
		emit_signal("status_applied", owner_id, "MISS")
		emit_signal("status_applied", target_id, "DODGED")
		return result

	var total_hits = max(1, my_card.repeat_count)
	for i in range(total_hits):
		var enemy_block = enemy_card.block_value 
		if my_card.guard_break: enemy_block = 0
		var net_damage = max(0, my_card.damage - enemy_block)
		
		if my_card.tiring > 0:
			if target.class_type == CharacterData.ClassType.HEAVY and target.current_sp < my_card.tiring:
				var drain_amount = my_card.tiring
				var sp_avail = target.current_sp
				var hp_cost = drain_amount - sp_avail
				target.current_sp = 0
				target.current_hp -= hp_cost
				emit_signal("combat_log_updated", ">> Rage! P" + str(target_id) + " takes " + str(hp_cost) + " HP dmg instead of SP.")
				emit_signal("damage_dealt", target_id, hp_cost, false)
			else:
				target.current_sp = max(0, target.current_sp - my_card.tiring)
				emit_signal("combat_log_updated", ">> Tiring! P" + str(target_id) + " drained of " + str(my_card.tiring) + " SP.")
		
		# --- NEW: GENERIC STATUS APPLICATION ---
		for effect in my_card.statuses_to_apply:
			# Default keys: "name" (String), "amount" (int), "self" (bool)
			var s_name = effect.get("name", "Unknown")
			var s_val = effect.get("amount", 1)
			var is_self = effect.get("self", false)
			
			var dest_id = owner_id if is_self else target_id
			
			# Apply it (using our helper from the previous step)
			if not has_status(dest_id, s_name):
				apply_status(dest_id, s_name, s_val)

		if my_card.create_opening > 0:
			emit_signal("combat_log_updated", "P" + str(owner_id) + " creates an Opening! (Lvl " + str(my_card.create_opening) + ")")
			result["opening"] = my_card.create_opening
		
		if my_card.opportunity > 0:
			result["opportunity"] = my_card.opportunity

		if net_damage > 0:
			target.current_hp -= net_damage
			emit_signal("damage_dealt", target_id, net_damage, false)
			emit_signal("combat_log_updated", "P" + str(owner_id) + " hits P" + str(target_id) + ": -" + str(net_damage) + " HP")
		elif my_card.damage > 0:
			emit_signal("combat_log_updated", "P" + str(owner_id) + " attack blocked (0 Dmg).")
			emit_signal("damage_dealt", target_id, 0, true)

		if my_card.damage > 0 and enemy_card.retaliate:
			var raw_recoil = my_card.damage
			var self_block = my_card.block_value + my_card.dodge_value 
			var net_recoil = max(0, raw_recoil - self_block)
			if net_recoil > 0:
				character.current_hp -= net_recoil
				emit_signal("combat_log_updated", ">> RETALIATE! P" + str(target_id) + " reflects " + str(net_recoil) + " dmg!")
				if character.current_hp <= 0:
					result["fatal"] = true
					return result
			else:
				emit_signal("combat_log_updated", ">> RETALIATE! Reflected damage blocked by P" + str(owner_id) + ".")

		if target.current_hp <= 0:
			result["fatal"] = true
			return result
			
	return result

# ==============================================================================
# HELPER FUNCTIONS
# ==============================================================================

func _calculate_projected_momentum(player_id: int, card: ActionData, is_active: bool) -> int:
	if not is_active: return 0
	var opp_val = _get_opportunity_value(player_id)
	var single_gain = card.momentum_gain + opp_val
	var total_gain = single_gain * max(1, card.repeat_count)
	return total_gain

func _get_opportunity_value(player_id: int) -> int:
	return p1_opportunity_stat if player_id == 1 else p2_opportunity_stat

func _pay_cost(player_id: int, card: ActionData) -> bool:
	var character = p1_data if player_id == 1 else p2_data
	var is_free = (p1_locked_card != null if player_id == 1 else p2_locked_card != null)
	var rage_is_on = (p1_rage_active if player_id == 1 else p2_rage_active)
	
	var raw_cost = card.cost
	var opp_val = _get_opportunity_value(player_id)
	var effective_single_cost = max(0, raw_cost - opp_val)
	var total_reps = max(1, card.repeat_count)
	var total_cost = effective_single_cost * total_reps
	
	if is_free: total_cost = 0
	
	if rage_is_on and character.class_type == CharacterData.ClassType.HEAVY:
		if character.current_hp > total_cost:
			character.current_hp -= total_cost
			emit_signal("combat_log_updated", ">> RAGE! P" + str(player_id) + " pays " + str(total_cost) + " HP.")
			emit_signal("damage_dealt", player_id, total_cost, false)
			return true
		else:
			emit_signal("combat_log_updated", ">> RAGE failed! Not enough HP.")
			return false
	
	if character.current_sp >= total_cost:
		character.current_sp -= total_cost
		return true
	else:
		if character.class_type == CharacterData.ClassType.HEAVY:
			if (character.current_sp + character.current_hp) > total_cost:
				var sp_avail = character.current_sp
				var hp_cost = total_cost - sp_avail
				character.current_sp = 0
				character.current_hp -= hp_cost
				emit_signal("combat_log_updated", ">> Rage! P" + str(player_id) + " pays " + str(hp_cost) + " HP for action.")
				emit_signal("damage_dealt", player_id, hp_cost, false)
				return true
		
		emit_signal("combat_log_updated", ">> P" + str(player_id) + " Out of SP! Action Fails!")
		return false

# Change arguments from '_p1_started_injured' to 'p1_started_injured' (remove underscores)
func _handle_status_damage(winner_id, p1_started_injured, p2_started_injured):
	# We iterate through players to apply End-of-Turn effects
	for id in [1, 2]:
		var player = p1_data if id == 1 else p2_data
		var started_injured = p1_started_injured if id == 1 else p2_started_injured
		
		# Check every status this player has
		for s_name in player.statuses.keys():
			match s_name:
				"Injured":
					if started_injured:
						player.current_hp -= 1
						emit_signal("combat_log_updated", ">> P" + str(id) + " suffers Injury damage!")
						emit_signal("damage_dealt", id, 1, false)
				"Poison":
					# EXAMPLE: Future proofing!
					var stacks = player.statuses["Poison"]
					player.current_hp -= stacks
					emit_signal("combat_log_updated", ">> P" + str(id) + " takes Poison dmg!")
					# Decay poison?
					# player.statuses["Poison"] -= 1
					
		if player.current_hp <= 0:
			_handle_death(winner_id)
			return

func _handle_death(winner_id):
	var game_winner = 0
	if p1_data.current_hp > 0: game_winner = 1
	elif p2_data.current_hp > 0: game_winner = 2
	else: game_winner = winner_id 
	emit_signal("game_over", game_winner)
	
	# REMOVED: reset_combat() 
	# We want the stats to stay at 0 so the player can see the final board state. 

func _check_reversal_state():
	var active_attacker = get_attacker()
	
	if attacker_override != 0:
		current_combo_attacker = attacker_override 
		if attacker_override == 1: p2_must_opener = true
		else: p1_must_opener = true
		return

	if active_attacker != 0:
		var att_data = p1_data if active_attacker == 1 else p2_data
		if att_data.current_sp <= 0:
			emit_signal("combat_log_updated", ">> Attacker Out of SP. Combo Ends.")
			current_combo_attacker = 0 
		else:
			current_combo_attacker = active_attacker
	else:
		current_combo_attacker = 0

func _handle_locks(winner_id):
	p1_locked_card = null; p2_locked_card = null
	var winner_card = p1_action_queue if winner_id == 1 else p2_action_queue
	var loser_card_obj = p2_action_queue if winner_id == 1 else p1_action_queue 
	if winner_card.multi_limit > 0:
		emit_signal("combat_log_updated", "Multi Triggered! Loser Locked.")
		if winner_id == 1: p2_locked_card = loser_card_obj
		else: p1_locked_card = loser_card_obj

func _update_turn_constraints(p1_res, p2_res, p1_card, p2_card, p1_parry_win: bool, p2_parry_win: bool):
	var next_p1_limit = 99; var next_p2_limit = 99
	var next_p1_opening = 0; var next_p2_opening = 0
	p1_must_opener = false; p2_must_opener = false
	
	if p1_res["opening"] > 0:
		next_p2_limit = min(next_p2_limit, p1_res["opening"]) 
		next_p1_opening = p1_res["opening"] 
	if p2_res["opening"] > 0:
		next_p1_limit = min(next_p1_limit, p2_res["opening"])
		next_p2_opening = p2_res["opening"]
	
	if p1_card.multi_limit > 0: next_p1_limit = min(next_p1_limit, p1_card.multi_limit)
	if p2_card.multi_limit > 0: next_p2_limit = min(next_p2_limit, p2_card.multi_limit)
		
	if p1_parry_win:
		p2_must_opener = true
		emit_signal("combat_log_updated", ">> P2 is unbalanced! Must use Opener next turn.")
	if p2_parry_win:
		p1_must_opener = true
		emit_signal("combat_log_updated", ">> P1 is unbalanced! Must use Opener next turn.")

	p1_cost_limit = next_p1_limit
	p2_cost_limit = next_p2_limit
	p1_opening_stat = next_p1_opening
	p2_opening_stat = next_p2_opening

	p1_opportunity_stat = p1_res["opportunity"]
	p2_opportunity_stat = p2_res["opportunity"]
	
	if p1_opportunity_stat > 0: emit_signal("combat_log_updated", "P1 gains Opportunity.")
	if p2_opportunity_stat > 0: emit_signal("combat_log_updated", "P2 gains Opportunity.")

func swap_priority():
	priority_player = 3 - priority_player

func get_player(id: int) -> CharacterData:
	return p1_data if id == 1 else p2_data

func get_opponent(id: int) -> CharacterData:
	return p2_data if id == 1 else p1_data

func is_p1_attacker() -> bool:
	if attacker_override == 1: return true
	if attacker_override == 2: return false
	if momentum == 0: return true
	return momentum <= MOMENTUM_P1_MAX

func clamp_momentum(val: int) -> int:
	return clampi(val, 1, TOTAL_MOMENTUM_SLOTS)

func get_advantage_momentum(player_id: int) -> int:
	if player_id == 1:
		return max(1, MOMENTUM_P1_MAX - 1)
	else:
		return min(TOTAL_MOMENTUM_SLOTS, MOMENTUM_P2_START + 1)

func get_wall_momentum(player_id: int) -> int:
	if player_id == 1: return 1
	else: return TOTAL_MOMENTUM_SLOTS

func apply_environment_rules(env_type: String):
	current_environment_name = env_type
	match env_type:
		"Ring": TOTAL_MOMENTUM_SLOTS = 6
		"Dojo": TOTAL_MOMENTUM_SLOTS = 8
		"Street": TOTAL_MOMENTUM_SLOTS = 10
		_: TOTAL_MOMENTUM_SLOTS = 8 
			
	MOMENTUM_P1_MAX = int(TOTAL_MOMENTUM_SLOTS / 2.0)
	MOMENTUM_P2_START = MOMENTUM_P1_MAX + 1
	
	print(">>> ENVIRONMENT SET: " + env_type + " (Momentum: " + str(TOTAL_MOMENTUM_SLOTS) + ")")

func _handle_patient_passive(player_id: int, card: ActionData):
	var character = p1_data if player_id == 1 else p2_data
	if character.class_type != CharacterData.ClassType.PATIENT: return
	
	var consumed_buff = false
	
	if character.patient_buff_active:
		card.damage += 1
		character.patient_buff_active = false 
		consumed_buff = true
		emit_signal("combat_log_updated", ">> P" + str(player_id) + " BIDE Unleashed! (+1 Dmg)")
		
	var total_fb = card.fall_back_value
	if total_fb > 0 and not consumed_buff:
		character.patient_buff_active = true
		emit_signal("combat_log_updated", ">> P" + str(player_id) + " Bides their time... (Next Action Buffed)")

func get_struggle_action(force_type: ActionData.Type) -> ActionData:
	var action = ActionData.new()
	action.display_name = "Struggle"
	action.description = "Offence, Defence, Recover 1, Fall Back 2"
	action.type = force_type
	action.cost = 0
	
	# Stats: Recover 1, Fall Back 1
	# Note: Defence actions naturally get +1 Recover in the rules, 
	# so Struggle (Def) will actually recover 2 SP, which makes sense (catching breath).
	action.recover_value = 1 
	action.fall_back_value = 2
	
	return action

func apply_status(target_id: int, status_name: String, value: int = 1):
	var target = p1_data if target_id == 1 else p2_data
	
	# Logic: If already exists, you might want to stack it or refresh it.
	# For "Injured", it's just a binary state (1), so overwriting is fine.
	target.statuses[status_name] = value
	
	emit_signal("status_applied", target_id, status_name)
	emit_signal("combat_log_updated", ">> P" + str(target_id) + " gained status: " + status_name)

func has_status(target_id: int, status_name: String) -> bool:
	var target = p1_data if target_id == 1 else p2_data
	return target.statuses.has(status_name)

func remove_status(target_id: int, status_name: String):
	var target = p1_data if target_id == 1 else p2_data
	if target.statuses.has(status_name):
		target.statuses.erase(status_name)
		emit_signal("status_applied", target_id, "CURED") # Generic cure msg

func _load_backgrounds():
	var path = "res://Art/background/"
	var dir = DirAccess.open(path)
	
	if dir:
		dir.list_dir_begin()
		var file_name = dir.get_next()
		
		while file_name != "":
			# Skip hidden files and imports
			if !dir.current_is_dir() and !file_name.ends_with(".import"):
				# Support PNG and JPG
				if file_name.ends_with(".png") or file_name.ends_with(".jpg"):
					
					# Key = "Dojo" (stripped of .png)
					var key = file_name.get_basename()
					
					# Load the image and store it
					environment_backgrounds[key] = load(path + file_name)
					print(">> Loaded Environment Art: " + key)
			
			file_name = dir.get_next()
	else:
		print("ERROR: Could not find 'res://Art/background/' folder.")


========================================
FILE PATH: res://Scripts/Resources/PresetCharacter.gd
========================================
extends Resource
class_name PresetCharacter

@export_group("Identity")
@export var character_name: String = "New Hero"
@export var class_type: CharacterData.ClassType = CharacterData.ClassType.HEAVY
@export var level: int = 1 # Mostly for flavor, or you could display it

@export_group("Build")
@export var extra_skills: Array[String] = [] # List the EXACT names of actions here (e.g. "Drop Kick")


========================================
FILE PATH: res://Scripts/RunManager.gd
========================================
extends Node

var is_arcade_mode: bool = false
var current_level: int = 1
var player_run_data: CharacterData
var player_owned_tree_ids: Array[int] = [] 
var free_unlocks_remaining: int = 0

# --- NEW: RUN MODIFIERS ---
var maintain_hp_enabled: bool = false
const EQUIPMENT_DIR = "res://Data/Equipment/"
const BOSS_DIR = "res://Data/Presets/Bosses/"

const BOSS_SCHEDULE = {
	5: "juggernaut_boss.tres",
	10: "grandmaster_boss.tres"
}

# ... (start_run and start_run_from_preset remain exactly the same) ...
var next_fight_statuses: Array[String] = []

# OPTION A: STANDARD RUN (Level 1, Drafting)
func start_run(starting_class: CharacterData.ClassType):
	is_arcade_mode = true
	current_level = 1
	player_run_data = ClassFactory.create_character(starting_class, "You")
	_init_tree_root(starting_class)
	free_unlocks_remaining = 1
	#player_run_data.equipment.append(load("res://Data/Equipment/EnergyDrink.tres"))
	SceneLoader.change_scene("res://Scenes/ActionTree.tscn")

# OPTION B: PRESET RUN
func start_run_from_preset(preset: PresetCharacter):
	is_arcade_mode = true
	current_level = max(1, preset.level)
	print("Starting Arcade Run with Preset: " + preset.character_name + " (Lv. " + str(current_level) + ")")
	
	player_run_data = ClassFactory.create_from_preset(preset)
	
	_init_tree_root(preset.class_type)
	for skill_name in preset.extra_skills:
		var id = ClassFactory.get_id_by_name(skill_name)
		if id != 0 and id not in player_owned_tree_ids:
			player_owned_tree_ids.append(id)
	
	free_unlocks_remaining = 0
	start_next_fight()

# Helper
func _init_tree_root(class_type: CharacterData.ClassType):
	#player_owned_tree_ids.clear()
	#match class_type:
		#CharacterData.ClassType.QUICK: player_owned_tree_ids.append(73)
		#CharacterData.ClassType.TECHNICAL: player_owned_tree_ids.append(74)
		#CharacterData.ClassType.PATIENT: player_owned_tree_ids.append(75)
		#CharacterData.ClassType.HEAVY: player_owned_tree_ids.append(76)
		
	player_owned_tree_ids.clear()
	
	# 1. Look up the Resource
	if ClassFactory.class_registry.has(class_type):
		var def = ClassFactory.class_registry[class_type]
		
		# 2. Read the Start Node from the File
		if def.skill_tree_root_id != 0:
			player_owned_tree_ids.append(def.skill_tree_root_id)
			return

	# Fallback (Safety)
	player_owned_tree_ids.append(76)

# --- UPDATED FIGHT GENERATION LOGIC ---
func start_next_fight():
	
	# --- NEW: APPLY EVENT STATUSES ---
	#for status in next_fight_statuses:
		#player_run_data.statuses[status] = 1
	#next_fight_statuses.clear() # Reset for the future
	# ---------------------------------
	
	# 1. Setup Player
	GameManager.next_match_p1_data = player_run_data
	
	# --- NEW: RANDOMIZE ENVIRONMENT ---
	var envs = ["Ring", "Dojo", "Street"]
	var selected_env = envs.pick_random()
	GameManager.apply_environment_rules(selected_env)
	# ----------------------------------
	
	# 2. CALCULATE TARGET LEVEL
	var raw_level = current_level
	
	# Apply Difficulty Modifier
	match GameManager.ai_difficulty:
		GameManager.Difficulty.VERY_EASY: raw_level -= 2
		GameManager.Difficulty.EASY:      raw_level -= 1
		GameManager.Difficulty.MEDIUM:    pass 
		GameManager.Difficulty.HARD:      raw_level += 1
	
	# 3. DETERMINE ACTUAL LEVEL & PENALTIES
	var final_enemy_level = raw_level
	var stat_penalty = 0
	
	if raw_level < 1:
		# If we dip below Level 1, stick to Level 1 but apply penalty.
		# Example: Level 1 on Very Easy (-2) = Raw -1. 
		# Penalty = 1 - (-1) = 2.
		stat_penalty = 1 - raw_level
		final_enemy_level = 1
		
	print("Generating Arcade Opponent: Difficulty ", GameManager.ai_difficulty, " -> Enemy Lv.", final_enemy_level)
	if stat_penalty > 0:
		print(">> UNDER-LEVEL PENALTY APPLIED: -", stat_penalty, " HP/SP")
	
# 4. Generate Enemy (MODIFIED FOR BOSSES)
	var enemy: CharacterData
	
	# Check if the CURRENT level has a scheduled boss
	if BOSS_SCHEDULE.has(current_level):
		var boss_path = BOSS_DIR + BOSS_SCHEDULE[current_level]
		var boss_preset = load(boss_path) as PresetCharacter
		
		# Generate the boss exactly as designed in the editor
		enemy = ClassFactory.create_from_preset(boss_preset)
		
		# Bosses scale slightly with difficulty
		if GameManager.ai_difficulty == GameManager.Difficulty.HARD:
			enemy.max_hp += 5
			enemy.max_sp += 1
		elif GameManager.ai_difficulty <= GameManager.Difficulty.EASY:
			enemy.max_hp = max(1, enemy.max_hp - 3)
			
		enemy.reset_stats()
		print(">> BOSS ENCOUNTER LOADED: " + enemy.character_name)
		
	else:
		# Standard Random Enemy
		enemy = ClassFactory.create_random_enemy(final_enemy_level, GameManager.ai_difficulty)
		
		# 5. Apply Stats Penalty (Only for standard enemies)
		if stat_penalty > 0:
			enemy.max_hp = max(1, enemy.max_hp - stat_penalty)
			enemy.max_sp = max(1, enemy.max_sp - stat_penalty)
			enemy.reset_stats()
			enemy.character_name += " (Weakened)"
	
	GameManager.next_match_p2_data = enemy
	
	# 6. Launch
	SceneLoader.change_scene("res://Scenes/VsScreen.tscn")

func handle_win():
	current_level += 1
	free_unlocks_remaining = 1 
	
	var level_beaten = current_level - 1
	
	# 1. Guaranteed Equipment (Every 3rd Win)
	if level_beaten > 0 and level_beaten % 3 == 0:
		print("Milestone Reached! Loading Equipment Draft...")
		SceneLoader.change_scene("res://Scenes/equipmentdraft.tscn")
		
	# 2. Random Event (35% Chance on normal wins)
	elif level_beaten > 0 and randf() < 0.35:
		print("Random Event Triggered!")
		SceneLoader.change_scene("res://Scenes/EventRoom.tscn")
		
	# 3. Standard Action Tree
	else:
		SceneLoader.change_scene("res://Scenes/ActionTree.tscn")

# Helper to fetch all equipment for the draft
func get_all_equipment() -> Array[EquipmentData]:
	var list: Array[EquipmentData] = []
	var dir = DirAccess.open(EQUIPMENT_DIR)
	if dir:
		dir.list_dir_begin()
		var file = dir.get_next()
		while file != "":
			if file.ends_with(".tres") or file.ends_with(".res"):
				var res = load(EQUIPMENT_DIR + file)
				if res is EquipmentData:
					list.append(res)
			file = dir.get_next()
	return list

func handle_loss():
	is_arcade_mode = false


========================================
FILE PATH: res://Scripts/RunStatusOverlay.gd
========================================
extends CanvasLayer

@onready var panel = $StatusPanel
@onready var btn_toggle = $ToggleBtn
@onready var hp_label = $StatusPanel/VBoxContainer/HpLabel
@onready var sp_label = $StatusPanel/VBoxContainer/SpLabel
@onready var eq_grid = $StatusPanel/VBoxContainer/EquipmentGrid

func _ready():
	panel.visible = false
	btn_toggle.pressed.connect(_on_toggle)
	btn_toggle.mouse_entered.connect(func(): AudioManager.play_sfx("ui_hover", 0.2))
	btn_toggle.pressed.connect(func(): AudioManager.play_sfx("ui_click"))

func _on_toggle():
	panel.visible = not panel.visible
	if panel.visible:
		btn_toggle.text = "Hide Run Status"
		_refresh_display()
	else:
		btn_toggle.text = "View Run Status"

func _refresh_display():
	var p1 = RunManager.player_run_data
	if not p1: return
	
	# 1. CALCULATE NEXT FIGHT STATS
	# HP is what you currently have. SP will reset to Max + any starting bonuses.
	var next_fight_hp = p1.current_hp
	var max_hp = p1.max_hp
	
	var max_sp = p1.max_sp
	var starting_sp_bonus = 0
	for item in p1.equipment:
		starting_sp_bonus += item.starting_sp_bonus
		
	var next_fight_sp = max_sp + starting_sp_bonus
	
	# Apply rich text colors for clarity
	hp_label.text = "NEXT FIGHT HP: " + str(next_fight_hp) + " / " + str(max_hp)
	sp_label.text = "NEXT FIGHT SP: " + str(next_fight_sp) + " / " + str(max_sp)

	# 2. POPULATE EQUIPMENT GRID (Same logic as BattleUI)
	for child in eq_grid.get_children():
		child.queue_free()
		
	for item in p1.equipment:
		var icon = TextureRect.new()
		icon.expand_mode = TextureRect.EXPAND_IGNORE_SIZE
		icon.custom_minimum_size = Vector2(40, 40)
		icon.stretch_mode = TextureRect.STRETCH_KEEP_ASPECT_CENTERED
		
		# Fallback icon
		if item.icon: icon.texture = item.icon
		else: icon.texture = preload("res://icon.svg") 
		
		# Build Tooltip
		var tip = item.display_name + "\n" + item.description + "\n"
		tip += "-------------------\n"
		if item.max_hp_bonus != 0: tip += "Max HP: " + ("+" if item.max_hp_bonus > 0 else "") + str(item.max_hp_bonus) + "\n"
		if item.max_sp_bonus != 0: tip += "Max SP: " + ("+" if item.max_sp_bonus > 0 else "") + str(item.max_sp_bonus) + "\n"
		if item.starting_sp_bonus != 0: tip += "Start SP: +" + str(item.starting_sp_bonus) + "\n"
		if item.wall_crush_damage_bonus != 0: tip += "Wall Crush Dmg: +" + str(item.wall_crush_damage_bonus)
		
		icon.tooltip_text = tip 
		eq_grid.add_child(icon)


========================================
FILE PATH: res://Scripts/SceneLoader.gd
========================================
extends CanvasLayer

@onready var anim = $AnimationPlayer
@onready var overlay = $BlackOverlay

func _ready():
	# Ensure we start invisible and don't block mouse clicks
	overlay.visible = false
	overlay.modulate.a = 0

func change_scene(path: String):
	# 1. Block input and Fade to Black
	anim.play("fade_in")
	await anim.animation_finished
	
	# 2. Actual Scene Change
	get_tree().change_scene_to_file(path)
	
	# 3. Optional: Pause briefly to ensure the new scene initializes fully
	# (Prevents one-frame stutters on heavy scenes)
	await get_tree().create_timer(0.1).timeout
	
	# 4. Fade back in
	anim.play("fade_out")
	await anim.animation_finished


========================================
FILE PATH: res://Scripts/TestArena.gd
========================================
extends Node2D

@export_group("Setup")
@export var p1_resource: CharacterData
@export var p2_resource: CharacterData
@export var stop_on_game_over: bool = true 

@export_group("Debug Controls")
@export var is_player_1_human: bool = true 
@export var is_player_2_human: bool = false 
@export var p2_debug_force_card: ActionData 

# AI Memory System
var p2_last_action_name: String = "" 
var p1_last_action_type = null # Store ActionData.Type (0 or 1)
var p1_last_cost: int = 0      # Track if player is tired

# NEW: Preload the Game Over Screen
var game_over_scene = preload("res://Scenes/GameOverScreen.tscn")
var game_over_screen

@onready var battle_ui = $BattleUI
var _simulation_active: bool = true
var _current_input_player: int = 1 

func _ready():
# --- FIX: SPAWN GAME OVER SCREEN ON A TOP LAYER ---
	var go_layer = CanvasLayer.new()
	go_layer.layer = 100 # Put it above everything else
	add_child(go_layer)
	
	game_over_screen = game_over_scene.instantiate()
	game_over_screen.visible = false
	game_over_screen.process_mode = Node.PROCESS_MODE_ALWAYS # Keep buttons active
	go_layer.add_child(game_over_screen)
	# ------------------------------------------------------
	# 1. UI SETUP
	# Since BattleUI is already in the scene tree, we just wait for it to be ready.
	# We DO NOT instantiate() it or add_child() it again.
	
	# Wait one frame to ensure the UI's own _ready() has finished setting up nodes
	await get_tree().process_frame
	
	# Clear the log to start fresh
	if battle_ui.has_method("combat_log") and battle_ui.combat_log:
		battle_ui.combat_log.clear_log()
	elif battle_ui.get("combat_log"): # Fallback access
		battle_ui.combat_log.clear_log()
	
	# 2. LOAD PLAYER RESOURCES
	if GameManager.next_match_p1_data != null:
		p1_resource = GameManager.next_match_p1_data
		
	if GameManager.next_match_p2_data != null:
		p2_resource = GameManager.next_match_p2_data
	
	# 3. DETERMINE HUMAN/AI STATUS
	is_player_1_human = true # P1 is always human
	
	# Logic: If Arcade Mode -> AI. If Custom Mode & P2 Toggle was Human -> Human.
	if not RunManager.is_arcade_mode and GameManager.p2_is_custom:
		is_player_2_human = true
		print("TestArena: P2 set to HUMAN")
	else:
		is_player_2_human = false
		print("TestArena: P2 set to AI")

	# 4. CONNECT SIGNALS
	# Note: We check if connections exist to avoid errors if _ready runs twice (rare but safe)
	if not GameManager.state_changed.is_connected(_on_state_changed):
		GameManager.state_changed.connect(_on_state_changed)
		GameManager.combat_log_updated.connect(_on_log_updated)
		GameManager.clash_resolved.connect(_on_clash_resolved)
		GameManager.game_over.connect(_on_game_over)
		GameManager.request_clash_animation.connect(battle_ui.play_clash_animation)
	
	if not battle_ui.human_selected_card.is_connected(_on_human_input_received):
		battle_ui.human_selected_card.connect(_on_human_input_received)
	
	# Connect Debug Toggles
	if not battle_ui.p1_mode_toggled.is_connected(_on_p1_mode_toggled):
		battle_ui.p1_mode_toggled.connect(_on_p1_mode_toggled)
		battle_ui.p2_mode_toggled.connect(_on_p2_mode_toggled)
	
	# 5. INITIALIZE UI ELEMENTS
	battle_ui.load_deck(p1_resource.deck)
	
	print("--- INITIALIZING MATCH ---")
	GameManager.start_combat(p1_resource, p2_resource)
	
	# 6. SETUP VISUALS & TOGGLES
	battle_ui.initialize_hud(p1_resource, p2_resource)
	
	# Pass the calculated booleans so the checkboxes match the game state
	battle_ui.setup_toggles(is_player_1_human, is_player_2_human)
	
	# 7. UPDATE NAME TAGS BASED ON DIFFICULTY
	var diff_suffix = ""
	match GameManager.ai_difficulty:
		GameManager.Difficulty.VERY_EASY: diff_suffix = " (V)"
		GameManager.Difficulty.EASY: diff_suffix = " (E)"
		GameManager.Difficulty.MEDIUM: diff_suffix = " (M)"
		GameManager.Difficulty.HARD: diff_suffix = " (H)"
	
	if not is_player_1_human:
		if battle_ui.p1_hud and battle_ui.p1_hud.name_label:
			battle_ui.p1_hud.name_label.text += diff_suffix
			
	if not is_player_2_human:
		if battle_ui.p2_hud and battle_ui.p2_hud.name_label:
			battle_ui.p2_hud.name_label.text += diff_suffix

func _update_visuals():
	battle_ui.update_all_visuals(p1_resource, p2_resource, GameManager.momentum)

# --- TOGGLE LOGIC ---

func _on_p1_mode_toggled(is_human: bool):
	is_player_1_human = is_human
	print("[DEBUG] P1 Human Mode: " + str(is_human))
	_check_mid_turn_state_change(1, is_human)

func _on_p2_mode_toggled(is_human: bool):
	is_player_2_human = is_human
	print("[DEBUG] P2 Human Mode: " + str(is_human))
	_check_mid_turn_state_change(2, is_human)

# Handles the case where we toggle Bot mode ON while waiting for that player
func _check_mid_turn_state_change(player_id: int, is_human: bool):
	# Only intervene if we are currently waiting for input from THIS player
	if _current_input_player != player_id: return
	
	# Check valid states for input
	if GameManager.current_state != GameManager.State.SELECTION and GameManager.current_state != GameManager.State.FEINT_CHECK:
		return

	# If switched TO BOT, force the bot to run immediately
	if not is_human:
		print(">>> TAKEOVER: Bot taking control of P" + str(player_id))
		battle_ui.lock_ui() # Hide the human UI
		_run_bot_turn(player_id)
	
	# If switched TO HUMAN, unlock the UI
	elif is_human:
		print(">>> TAKEOVER: Human taking control of P" + str(player_id))
		_prepare_human_turn(player_id)

# --- GAME LOOP ---

func _on_state_changed(new_state):
	if not _simulation_active: return

	match new_state:
		GameManager.State.SELECTION:
			await get_tree().create_timer(0.5).timeout
			_start_turn_sequence()
			
		GameManager.State.FEINT_CHECK:
			await get_tree().create_timer(0.3).timeout
			print("| --- FEINT PHASE --- |")
			_start_feint_input()

		GameManager.State.POST_CLASH:
			_print_status_report()

func _start_turn_sequence():
	if is_player_1_human: _prepare_human_turn(1)
	else:
		print("\n| --- NEW TURN: AI P1 --- |")
		_run_bot_turn(1)

func _start_feint_input():
	if GameManager.p1_pending_feint:
		print("| --- WAITING FOR P1 FEINT SELECTION --- |")
		if is_player_1_human: _prepare_human_turn(1)
		else: _run_bot_turn(1)
	elif GameManager.p2_pending_feint:
		print("| --- WAITING FOR P2 FEINT SELECTION --- |")
		if is_player_2_human: _prepare_human_turn(2)
		else: _run_bot_turn(2)

func _get_player_constraints(player_id: int) -> Dictionary:
	# This function asks GameManager who is attacking. 
	# Now that we fixed 'get_attacker', this will return the correct ID!
	var attacker_id = GameManager.get_attacker()
	var is_combo = (GameManager.current_combo_attacker != 0)
	var mom = GameManager.momentum
	
	var c = {
		"filter": null, "required_tab": null, "needs_opener": false,
		"max_cost": 99, "opening_stat": 0, "can_use_super": false, "opportunity_stat": 0 
	}
	
	# 1. Setup Limits & Stats
	if player_id == 1:
		c.max_cost = GameManager.p1_cost_limit
		c.opening_stat = GameManager.p1_opening_stat
		c.opportunity_stat = GameManager.p1_opportunity_stat 
		
		# SUPER CHECK (Updated for Dynamic Momentum)
		# Checks if momentum is at P1's Wall (e.g. 1)
		if mom == GameManager.get_wall_momentum(1) and not p1_resource.has_used_super:
			c.can_use_super = true
			
		if GameManager.p1_must_opener: c.needs_opener = true
	else:
		c.max_cost = GameManager.p2_cost_limit
		c.opening_stat = GameManager.p2_opening_stat
		c.opportunity_stat = GameManager.p2_opportunity_stat 
		
		# SUPER CHECK (Updated for Dynamic Momentum)
		# Checks if momentum is at P2's Wall (e.g. 8 or 12)
		if mom == GameManager.get_wall_momentum(2) and not p2_resource.has_used_super:
			c.can_use_super = true
			
		if GameManager.p2_must_opener: c.needs_opener = true

	# 2. Determine Required Tab (Offence vs Defence)
	if attacker_id != 0:
		if attacker_id == player_id:
			c.filter = ActionData.Type.OFFENCE
			c.required_tab = ActionData.Type.OFFENCE
		else:
			c.filter = ActionData.Type.DEFENCE
			c.required_tab = ActionData.Type.DEFENCE
			
	# 3. Neutral / Opener Logic
	if mom == 0: 
		c.needs_opener = true
	elif attacker_id == player_id and not is_combo: 
		# If I am attacking and NOT in a combo, I must use an opener to start one
		c.needs_opener = true
		
	return c

func _prepare_human_turn(player_id: int):
	_current_input_player = player_id
	var character = p1_resource if player_id == 1 else p2_resource
	
	# --- NEW: SETUP UI TOGGLES ---
	battle_ui.setup_passive_toggles(character.class_type)
	# -----------------------------
	battle_ui.load_deck(character.deck)
	
	var locked_card = GameManager.p1_locked_card if player_id == 1 else GameManager.p2_locked_card
	if locked_card and GameManager.current_state == GameManager.State.SELECTION:
		print(">>> P" + str(player_id) + " LOCKED into: " + locked_card.display_name)
		_on_human_input_received(locked_card)
		return

	var c = _get_player_constraints(player_id)
	var is_feinting = (GameManager.current_state == GameManager.State.FEINT_CHECK)
	
	if is_feinting:
		print("[GUIDE P" + str(player_id) + "] Feint! Choose a card to combine, or 'SKIP FEINT'.")
	else:
		if c.required_tab == ActionData.Type.OFFENCE: print("[GUIDE P" + str(player_id) + "] Attack!")
		elif c.required_tab == ActionData.Type.DEFENCE: print("[GUIDE P" + str(player_id) + "] Defend!")
		else: print("[GUIDE P" + str(player_id) + "] Neutral.")
	
	_update_visuals() 
	print("| --- WAITING FOR P" + str(player_id) + " INPUT --- |")
	
	battle_ui.unlock_for_input(
		c.required_tab, character.current_sp, character.current_hp, c.needs_opener, c.max_cost, c.opening_stat,
		c.can_use_super, c.opportunity_stat, is_feinting
	)

func _on_human_input_received(card: ActionData, extra_data: Dictionary = {}): # Updated Signature
	print(">>> P" + str(_current_input_player) + " COMMITTED: " + card.display_name)
	
	var action_to_submit = card
	if card.display_name == "SKIP FEINT": action_to_submit = null
	
	# Pass the extra data (toggles) to GameManager
	GameManager.player_select_action(_current_input_player, action_to_submit, extra_data)
	
	if GameManager.current_state == GameManager.State.SELECTION:
		if _current_input_player == 1:
			if is_player_2_human:
				await get_tree().create_timer(0.2).timeout
				_prepare_human_turn(2)
			else: _run_bot_turn(2)
				
	elif GameManager.current_state == GameManager.State.FEINT_CHECK:
		await get_tree().create_timer(0.2).timeout
		_start_feint_input() 

func _run_bot_turn(player_id: int):
	_current_input_player = player_id # Ensure tracker is correct for mid-turn switches
	var character = p1_resource if player_id == 1 else p2_resource
	
	if player_id == 2 and p2_debug_force_card != null and GameManager.current_state == GameManager.State.SELECTION:
		print(">>> DEBUG FORCE P2: " + p2_debug_force_card.display_name)
		GameManager.player_select_action(2, p2_debug_force_card)
		return

	var locked_card = GameManager.p1_locked_card if player_id == 1 else GameManager.p2_locked_card
	if locked_card and GameManager.current_state == GameManager.State.SELECTION:
		print(">>> BOT P" + str(player_id) + " LOCKED into: " + locked_card.display_name)
		_handle_bot_completion(player_id)
		return

	var c = _get_player_constraints(player_id)
	
	var card = _get_smart_card_choice(character, c.filter, c.needs_opener, c.max_cost, c.opening_stat, c.can_use_super, c.opportunity_stat)
	print(">>> BOT P" + str(player_id) + " COMMITTED: " + card.display_name)
	GameManager.player_select_action(player_id, card)
	
	if GameManager.current_state == GameManager.State.SELECTION: _handle_bot_completion(player_id)
	elif GameManager.current_state == GameManager.State.FEINT_CHECK:
		await get_tree().create_timer(0.2).timeout
		_start_feint_input()

func _handle_bot_completion(player_id):
	if player_id == 1:
		if is_player_2_human: _prepare_human_turn(2)
		else: _run_bot_turn(2)

# TestArena.gd

# TestArena.gd

func _get_smart_card_choice(character: CharacterData, type_filter, must_be_opener: bool, max_cost: int, my_opening: int, allow_super: bool, my_opportunity: int) -> ActionData:
	var valid_options = []
	var affordable_backups = [] 
	
	# A. FILTER (Same as before)
	for card in character.deck:
		if type_filter != null and card.type != type_filter: continue
		if must_be_opener and card.type == ActionData.Type.OFFENCE and not card.is_opener: continue
		if card.cost > max_cost: continue
		if card.counter_value > 0 and my_opening < card.counter_value: continue
		if card.is_super and not allow_super: continue
		
		var effective_cost = max(0, card.cost - my_opportunity)
		var can_pay = (effective_cost <= character.current_sp)
		
		if character.class_type == CharacterData.ClassType.HEAVY:
			if (character.current_sp + character.current_hp) > effective_cost:
				can_pay = true
				
		if can_pay:
			valid_options.append(card)
		elif effective_cost == 0:
			affordable_backups.append(card)
	
	# --- FIX: ADD STRUGGLE OPTION ---
	# If the bot is filtering for a specific type (e.g. Defence), give it the Struggle option for that type.
	var required_type = type_filter if type_filter != null else ActionData.Type.OFFENCE
	var struggle = GameManager.get_struggle_action(required_type)
	
	# If we have NO valid deck options, or if we just want to consider saving SP, add Struggle.
	# Adding it to 'valid_options' lets the Scoring System decide if it's a good idea.
	valid_options.append(struggle)
	# --------------------------------
	
	if valid_options.is_empty():
		return struggle 

	# B. STRATEGY
	var best_card = valid_options[0]
	
	# --- NEW LOGIC START ---
	var is_very_easy = (GameManager.ai_difficulty == GameManager.Difficulty.VERY_EASY)
	
	# If Very Easy: We want the LOWEST score, so start High.
	# If Normal: We want the HIGHEST score, so start Low.
	var best_score = 99999.0 if is_very_easy else -99999.0
	
	var my_id = 1 if character == p1_resource else 2
	var opponent = p2_resource if my_id == 1 else p1_resource
	
	# Noise Setup
	var noise_range = 0.0
	match GameManager.ai_difficulty:
		GameManager.Difficulty.VERY_EASY: noise_range = 0 # No noise, just pure bad decisions
		GameManager.Difficulty.EASY: noise_range = 100.0
		GameManager.Difficulty.MEDIUM: noise_range = 25.0
		GameManager.Difficulty.HARD: noise_range = 2.0
	
	for card in valid_options:
		var score = _score_card_utility(card, character, opponent, my_id)
		score += randf_range(-noise_range, noise_range)
		
		if is_very_easy:
			# INVERTED LOGIC: Pick the WORST score
			if score < best_score:
				best_score = score
				best_card = card
		else:
			# STANDARD LOGIC: Pick the BEST score
			if score > best_score:
				best_score = score
				best_card = card
	
	return best_card

# 2. THE BRAIN (Assigns value to actions)
func _score_card_utility(card: ActionData, me: CharacterData, opp: CharacterData, my_id: int) -> float:
	var score = 0.0
	var log_parts = [] # Stores reasons like "+10 Dmg" or "-100 Repetition"
	
	# Weights
	var w_dmg = 1.0; var w_def = 1.0; var w_tech = 1.0; var w_cost = 1.0
	
	match me.ai_archetype:
		CharacterData.AIArchetype.AGGRESSIVE:
			w_dmg = 1.5; w_def = 0.5; w_cost = 0.5
		CharacterData.AIArchetype.DEFENSIVE:
			w_dmg = 0.7; w_def = 1.5; w_cost = 1.2
		CharacterData.AIArchetype.TRICKSTER:
			w_dmg = 0.8; w_def = 0.8; w_tech = 1.5
	
	# --- 1. STRICT ANTI-REPETITION ---
	if card.display_name == p2_last_action_name:
		if GameManager.ai_difficulty == GameManager.Difficulty.VERY_EASY:
			# [cite_start]FIX: For Very Easy, we pick the LOWEST score[cite: 220].
			# To discourage repetition, we must ADD to the score so it isn't the lowest.
			score += 100.0
			log_parts.append("+100 (Repetition Avoidance)")
		else:
			# Normal Logic: We pick the HIGHEST score.
			# Subtracting makes the AI avoid it.
			score -= 100.0
			log_parts.append("-100 (Repetition)")

	# --- 2. TACTICAL RESPONSE ---
	if card.type == ActionData.Type.OFFENCE:
		# Counter Opportunities
		var opp_opening = GameManager.p1_opening_stat if my_id == 2 else GameManager.p2_opening_stat
		if opp_opening > 0 and card.counter_value > 0 and card.counter_value <= opp_opening:
			var val = 50.0 * w_tech
			score += val
			log_parts.append("+" + str(val) + " (Counter Opportunity)")
		
		# Punish Tired
		if p1_last_cost >= 2 or (float(opp.current_sp)/max(1, opp.max_sp) < 0.3):
			var val = card.damage * 5 * w_dmg
			score += val
			log_parts.append("+" + str(val) + " (Punish Tired)")
		
		# Break Turtles
		if p1_last_action_type == ActionData.Type.DEFENCE:
			if card.guard_break: 
				score += 30 * w_tech
				log_parts.append("+30 (Guard Break)")
			if card.feint: 
				score += 20 * w_tech
				log_parts.append("+20 (Feint vs Block)")
			
	elif card.type == ActionData.Type.DEFENCE:
		# Heavy Incoming
		if p1_last_cost >= 2:
			if card.dodge_value > 0: 
				score += 20 * w_def
				log_parts.append("+20 (Dodge Heavy)")
			if card.block_value >= 4: 
				score += 15 * w_def
				log_parts.append("+15 (Block Heavy)")
			
		# Light Incoming
		elif p1_last_cost <= 1:
			if card.cost >= 2: 
				var pen = 15.0 * w_cost
				score -= pen
				log_parts.append("-" + str(pen) + " (Overkill Def)")
			if card.block_value > 0 and card.cost <= 1: 
				score += 10 * w_def
				log_parts.append("+10 (Efficient Block)")

		# Fishing for Reversals
		if opp.current_hp <= 5 and card.reversal:
			score += 15 * w_tech
			log_parts.append("+15 (Execute Reversal)")

	# --- 3. UTILITY SCORING ---
	
	# Kill Instinct
	if card.damage >= opp.current_hp: 
		score += 1000.0
		log_parts.append("+1000 (KILL SHOT)")
	
	# Survival Instinct
	var panic = 5 if me.ai_archetype == CharacterData.AIArchetype.DEFENSIVE else 3
	if me.current_hp < panic:
		var s_val = (card.block_value * 10 * w_def) + (card.heal_value * 15 * w_def)
		if card.type == ActionData.Type.DEFENCE: s_val += 20 * w_def
		score += s_val
		if s_val > 0: log_parts.append("+" + str(s_val) + " (Panic Mode)")
	
	# Logic for Struggle (display_name check)
	if card.display_name == "Struggle":
		# If we are low on SP, Struggle is very valuable
		if me.current_sp <= 1:
			score += 50.0
			log_parts.append("+50 (Need SP)")
		# If we are full on SP, Struggle is bad
		elif me.current_sp >= me.max_sp:
			score -= 50.0
			log_parts.append("-50 (SP Full)")
	
	# Momentum Logic
	var mom = GameManager.momentum
	var winning = (my_id == 1 and mom <= 3) or (my_id == 2 and mom >= 6)
	var losing = (my_id == 1 and mom >= 5) or (my_id == 2 and mom <= 4)
	
	if winning:
		var m_val = (card.damage * 10 * w_dmg)
		if card.type == ActionData.Type.OFFENCE: m_val += 10
		score += m_val
		if m_val > 0: log_parts.append("+" + str(m_val) + " (Winning Mom)")
	elif losing:
		var m_val = (card.fall_back_value * 10 * w_def) + (card.block_value * 5 * w_def)
		if card.reversal: m_val += 20 * w_tech
		score += m_val
		if m_val > 0: log_parts.append("+" + str(m_val) + " (Losing Mom)")

	# Base Stats
	var stat_score = (card.damage * 5 * w_dmg) + (card.block_value * 5 * w_def) + (card.heal_value * 5 * w_def)
	
	if card.tiring > 0: stat_score += card.tiring * 5 * w_tech
	if card.create_opening > 0: stat_score += card.create_opening * 5 * w_tech
	if card.feint: stat_score += 10 * w_tech
	
	score += stat_score
	log_parts.append("+" + str(stat_score) + " (Stats)")
	
	# Cost Efficiency
	if card.cost > 0:
		var sp_ratio = float(me.current_sp) / float(max(1, me.max_sp))
		var scarcity = 1.0 if sp_ratio > 0.5 else 2.5
		var c_pen = card.cost * (10 * w_cost * scarcity)
		score -= c_pen
		log_parts.append("-" + str(c_pen) + " (Cost)")

	# --- PRINT LOG ---
	# Format: [AI] CardName: 45.0 | Breakdown: +20 (Stats), -5 (Cost), +30 (Counter)
	print("[AI] %s: %s | %s" % [card.display_name, str(snapped(score, 0.1)), ", ".join(log_parts)])

	return score

# --- LOGGING ---
func _on_game_over(winner_id: int):
	# 1. Force one final visual update so the HP bar shows 0
	_update_visuals()
	
	# 2. Wait 1 second so the player can see the final hit land
	await get_tree().create_timer(1.0).timeout
	
	# 3. Now we pause and show the screen
	get_tree().paused = true 
	game_over_screen.setup(winner_id)
	game_over_screen.visible = true
	
	
func _on_clash_resolved(winner_id, p1_card, p2_card, _results): 
	print("\n>>> Clash Winner: P" + str(winner_id))
	_update_visuals()
	# --- UPDATE AI MEMORY ---
	if not is_player_2_human:
		# 1. Remember what the Bot did (for anti-repetition)
		if p2_card != null:
			p2_last_action_name = p2_card.display_name
			
		# 2. Remember what the Human did (for counter-play)
		if p1_card != null:
			p1_last_action_type = p1_card.type
			p1_last_cost = p1_card.cost
			
			# Reset if Human did nothing (stunned/empty)
		else:
			p1_last_action_type = null
			p1_last_cost = 0
		
func _on_log_updated(text): print("   > " + text)
func _print_status_report():
	var p1 = p1_resource; var p2 = p2_resource
	var visual = "[ "; for i in range(1, 5): visual += ("P1 " if GameManager.momentum == i else str(i) + " ")
	visual += "| "; for i in range(5, 9): visual += ("P2 " if GameManager.momentum == i else str(i) + " ")
	visual += "]"
	print("\n[STATUS] P1: " + str(p1.current_hp) + "HP/" + str(p1.current_sp) + "SP  vs  P2: " + str(p2.current_hp) + "HP/" + str(p2.current_sp) + "SP")
	print("[MOMENTUM] " + visual)


========================================
FILE PATH: res://Scripts/Tools/ActionImporter.gd
========================================
@tool
extends EditorScript

const CSV_PATH = "res://Data/ALLACTIONS.csv"
const SAVE_DIR = "res://Data/Actions/"

func _run():
	if not FileAccess.file_exists(CSV_PATH):
		print("Error: Could not find " + CSV_PATH)
		return

	var file = FileAccess.open(CSV_PATH, FileAccess.READ)
	
	# Create the directory if it doesn't exist
	var dir = DirAccess.open("res://")
	if not dir.dir_exists(SAVE_DIR):
		dir.make_dir_recursive(SAVE_DIR)
		
	print("--- Starting Import from ALLACTIONS.csv ---")
	
	while not file.eof_reached():
		var line = file.get_csv_line()
		if line.size() < 27: continue # Skip empty lines
		
		# 1. Create the Resource Instance
		var action = ActionData.new()
		
		# 2. Map Columns (0-27)
		action.display_name = line[0]
		action.description = line[1]
		
		action.block_value = int(line[2])
		action.cost = int(line[3])
		action.counter_value = int(line[4])
		action.create_opening = int(line[5])
		action.damage = int(line[6])
		
		# Type Logic: Offence column (16) takes priority, otherwise Defence (7)
		var is_offence = (line[16].to_lower() == "true")
		if is_offence:
			action.type = ActionData.Type.OFFENCE
		else:
			action.type = ActionData.Type.DEFENCE
			
		action.feint = (line[8].to_lower() == "true") # Column 8 is "Ditto" (Feint)
		action.dodge_value = int(line[9])
		action.fall_back_value = int(line[10])
		action.guard_break = (line[11].to_lower() == "true")
		action.heal_value = int(line[12])
		#--- FIX: MAP OLD CSV COLUMN TO NEW ARRAY ---
		if line[13].to_lower() == "true":
			action.statuses_to_apply.append({ 
				"name": "Injured", 
				"amount": 1,
				"self": false
			})
		action.momentum_gain = int(line[14])
		action.multi_limit = int(line[15])
		action.is_opener = (line[17].to_lower() == "true")
		action.opportunity = int(line[18])
		action.is_parry = (line[19].to_lower() == "true")
		action.recover_value = int(line[20])
		action.repeat_count = int(line[21])
		action.retaliate = (line[22].to_lower() == "true")
		action.reversal = (line[23].to_lower() == "true")
		action.is_super = (line[24].to_lower() == "true")
		action.sweep = (line[25].to_lower() == "true")
		action.tiring = int(line[26])
		
		# 3. Apply Hard-Coded Fixes (The "Harsh" Audit)
		if action.display_name == "Vital Point Assault" and action.repeat_count == 3:
			print("Applying v0.3 Fix: Vital Point Assault Repeat 3 -> 2")
			action.repeat_count = 2
			
		# 4. Generate Filename (snake_case)
		# "Basic Light" -> "basic_light.tres"
		var filename = action.display_name.to_lower().replace(" ", "_").replace("'", "") + ".tres"
		action.id = filename.replace(".tres", "") # internal ID matches filename
		
		# 5. Save
		var err = ResourceSaver.save(action, SAVE_DIR + filename)
		if err == OK:
			print("Saved: " + filename)
		else:
			print("Failed to save: " + filename)

	print("--- Import Complete ---")
	# Refresh Editor
	var editor = EditorInterface.get_resource_filesystem()
	editor.scan()


========================================
FILE PATH: res://Scripts/Tools/BulkIconAssigner.gd
========================================
@tool
extends EditorScript

# --- CONFIGURATION ---
const ACTIONS_FOLDER = "res://Data/Actions/"

# REPLACE THESE WITH YOUR ACTUAL ICON PATHS
const OFFENCE_ICON_PATH = "res://Art/OffenceBasic.jpg"
const DEFENCE_ICON_PATH = "res://Art/DefenceBasic.jpg"

func _run():
	# 1. Load the icons
	var off_icon = load(OFFENCE_ICON_PATH)
	var def_icon = load(DEFENCE_ICON_PATH)

	# Safety Check
	if not off_icon or not def_icon:
		printerr("Error: Could not load one or both icons. Check the paths!")
		return

	print("--- STARTING SMART BULK UPDATE ---")
	
	# 2. Start scanning
	_scan_directory(ACTIONS_FOLDER, off_icon, def_icon)
	
	print("--- COMPLETE! ---")

func _scan_directory(path: String, off_icon: Texture2D, def_icon: Texture2D):
	var dir = DirAccess.open(path)
	if dir:
		dir.list_dir_begin()
		var file_name = dir.get_next()
		
		while file_name != "":
			if dir.current_is_dir():
				if file_name != "." and file_name != "..":
					_scan_directory(path + file_name + "/", off_icon, def_icon)
			else:
				if file_name.ends_with(".tres"):
					_apply_icon_to_file(path + file_name, off_icon, def_icon)
			
			file_name = dir.get_next()

func _apply_icon_to_file(file_path: String, off_icon: Texture2D, def_icon: Texture2D):
	var resource = ResourceLoader.load(file_path)
	
	if resource is ActionData:
		var target_icon = null
		
		# --- LOGIC: CHOOSE ICON BASED ON TYPE ---
		if resource.type == ActionData.Type.OFFENCE:
			target_icon = off_icon
		elif resource.type == ActionData.Type.DEFENCE:
			target_icon = def_icon
			
		# Apply if we found a valid type
		if target_icon:
			# OPTIONAL: Check 'if resource.icon == null:' if you only want to fill empty ones.
			# Currently, this overwrites everything so you can fix incorrect icons.
			if resource.icon != target_icon:
				resource.icon = target_icon
				ResourceSaver.save(resource, file_path)
				print("Updated: " + file_path + " -> " + ("Offence" if resource.type == 0 else "Defence"))


========================================
FILE PATH: res://Scripts/Tools/ProjectDumper.gd
========================================
@tool
extends EditorScript

# Files to ignore (e.g. addons usually don't need reviewing)
const IGNORE_DIRS = [".", "..", ".godot", "addons", "android", "ios"]

func _run():
	var all_code = "--- START OF PROJECT DUMP ---\n"
	all_code += _scan_directory("res://")
	
	# Save to the root of your project
	var save_path = "res://FullProjectCode.txt"
	var file = FileAccess.open(save_path, FileAccess.WRITE)
	if file:
		file.store_string(all_code)
		file.close()
		print("SUCCESS! All scripts dumped to: " + save_path)
		print("You can now upload 'FullProjectCode.txt' to the chat.")
	else:
		printerr("Failed to save dump file.")

func _scan_directory(path: String) -> String:
	var output = ""
	var dir = DirAccess.open(path)
	if dir:
		dir.list_dir_begin()
		var file_name = dir.get_next()
		
		while file_name != "":
			if dir.current_is_dir():
				if not file_name in IGNORE_DIRS:
					output += _scan_directory(path + file_name + "/")
			else:
				# We only care about scripts (.gd) and maybe headers (.tscn if you want structure)
				# For code cleanup, .gd is usually enough.
				if file_name.ends_with(".gd"):
					output += "\n\n========================================\n"
					output += "FILE PATH: " + path + file_name + "\n"
					output += "========================================\n"
					
					var f = FileAccess.open(path + file_name, FileAccess.READ)
					if f:
						output += f.get_as_text()
						f.close()
			
			file_name = dir.get_next()
	return output


========================================
FILE PATH: res://Scripts/Tools/SceneDumper.gd
========================================
@tool
extends EditorScript

# Folders to ignore to keep the dump clean
const IGNORE_DIRS = [".", "..", ".godot", "addons", "android", "ios", ".import"]

# The output file name
const OUTPUT_FILE = "res://FullProjectScenes.txt"

func _run():
	print("--- STARTING SCENE DUMP ---")
	
	var all_text = "--- GODOT PROJECT SCENE DUMP ---\n"
	all_text += "Generated: " + Time.get_datetime_string_from_system() + "\n\n"
	
	all_text += _scan_directory("res://")
	
	var file = FileAccess.open(OUTPUT_FILE, FileAccess.WRITE)
	if file:
		file.store_string(all_text)
		file.close()
		print("SUCCESS! Scene data dumped to: " + OUTPUT_FILE)
		print("You can now upload 'FullProjectScenes.txt'.")
		
		# Refresh the FileSystem so the new file appears immediately
		EditorInterface.get_resource_filesystem().scan()
	else:
		printerr("Failed to write output file.")

func _scan_directory(path: String) -> String:
	var output = ""
	var dir = DirAccess.open(path)
	
	if dir:
		dir.list_dir_begin()
		var file_name = dir.get_next()
		
		while file_name != "":
			if dir.current_is_dir():
				if not file_name in IGNORE_DIRS:
					output += _scan_directory(path + file_name + "/")
			else:
				# We look specifically for Text Scenes (.tscn)
				# We ignore .scn because those are binary and unreadable
				if file_name.ends_with(".tscn"):
					output += _read_file_content(path + file_name)
					
			file_name = dir.get_next()
	else:
		printerr("Failed to open directory: " + path)
		
	return output

func _read_file_content(file_path: String) -> String:
	var content = ""
	
	# Header for readability
	content += "========================================\n"
	content += "FILE PATH: " + file_path + "\n"
	content += "========================================\n"
	
	var file = FileAccess.open(file_path, FileAccess.READ)
	if file:
		content += file.get_as_text()
		file.close()
	else:
		content += "[ERROR READING FILE]\n"
		
	content += "\n\n"
	return content


========================================
FILE PATH: res://Scripts/VFXManager.gd
========================================
extends CanvasLayer

func _ready():
	layer = 5 
	GameManager.clash_resolved.connect(_on_clash_resolved)
	GameManager.damage_dealt.connect(_on_damage_dealt)
	GameManager.healing_received.connect(_on_healing_received)
	GameManager.wall_crush_occurred.connect(_on_wall_crush)
	
	# NEW: Listen for status updates to trigger Dodge effects
	GameManager.status_applied.connect(_on_status_applied)
	
	print("VFX Manager Initialized")

# ==============================================================================
# 1. PARTICLE GENERATORS (Templates)
# ==============================================================================

# ... (Keep _create_clash_particles as is) ...
func _create_clash_particles() -> GPUParticles2D:
	var p = GPUParticles2D.new()
	p.amount = 30
	p.lifetime = 0.5
	p.one_shot = true
	p.explosiveness = 1.0
	var img = Image.create(4, 4, false, Image.FORMAT_RGBA8)
	img.fill(Color.WHITE)
	p.texture = ImageTexture.create_from_image(img)
	var mat = ParticleProcessMaterial.new()
	mat.direction = Vector3(0, 0, 0)
	mat.spread = 180
	mat.initial_velocity_min = 300
	mat.initial_velocity_max = 500
	mat.gravity = Vector3(0, 0, 0)
	mat.scale_min = 4.0
	mat.scale_max = 4.0
	var grad = Gradient.new()
	grad.set_color(0, Color.YELLOW)
	grad.set_color(1, Color(1, 0.5, 0, 0))
	var grad_tex = GradientTexture1D.new()
	grad_tex.gradient = grad
	mat.color_ramp = grad_tex
	p.process_material = mat
	return p

# ... (Keep _create_block_particles as is) ...
func _create_block_particles() -> GPUParticles2D:
	var p = GPUParticles2D.new()
	p.amount = 1; p.lifetime = 0.4; p.one_shot = true
	var tex = GradientTexture2D.new()
	tex.width = 128; tex.height = 128; tex.fill = GradientTexture2D.FILL_RADIAL
	var grad = Gradient.new()
	grad.remove_point(0)
	grad.add_point(0.5, Color(1, 1, 1, 0))
	grad.add_point(0.65, Color(1, 1, 1, 1))
	grad.add_point(0.7, Color(1, 1, 1, 0))
	tex.gradient = grad
	p.texture = tex
	var mat = ParticleProcessMaterial.new()
	mat.gravity = Vector3(0, 0, 0)
	mat.color = Color(0.2, 0.8, 1.0, 0.8)
	var curve = Curve.new()
	curve.add_point(Vector2(0, 0.5)); curve.add_point(Vector2(1, 1.2))
	var curve_tex = CurveTexture.new()
	curve_tex.curve = curve
	mat.scale_curve = curve_tex
	p.process_material = mat
	return p

# ... (Keep _create_hit_particles as is) ...
func _create_hit_particles() -> GPUParticles2D:
	var p = GPUParticles2D.new()
	p.amount = 15; p.lifetime = 0.6; p.one_shot = true; p.explosiveness = 0.9
	var img = Image.create(4, 4, false, Image.FORMAT_RGBA8)
	img.fill(Color.WHITE)
	p.texture = ImageTexture.create_from_image(img)
	var mat = ParticleProcessMaterial.new()
	mat.direction = Vector3(0, -1, 0); mat.spread = 45
	mat.initial_velocity_min = 200; mat.initial_velocity_max = 400
	mat.gravity = Vector3(0, 900, 0); mat.scale_min = 3.0; mat.scale_max = 5.0
	var grad = Gradient.new()
	grad.set_color(0, Color(1, 0.1, 0.1)); grad.set_color(1, Color(0.5, 0, 0, 0))
	var grad_tex = GradientTexture1D.new()
	grad_tex.gradient = grad
	mat.color_ramp = grad_tex
	p.process_material = mat
	return p

# ... (Keep _create_heal_particles as is) ...
func _create_heal_particles() -> GPUParticles2D:
	var p = GPUParticles2D.new()
	p.amount = 8; p.lifetime = 1.0; p.one_shot = true
	var img = Image.create(3, 3, false, Image.FORMAT_RGBA8)
	img.fill(Color.WHITE)
	p.texture = ImageTexture.create_from_image(img)
	var mat = ParticleProcessMaterial.new()
	mat.emission_shape = ParticleProcessMaterial.EMISSION_SHAPE_SPHERE
	mat.emission_sphere_radius = 40.0; mat.gravity = Vector3(0, -100, 0)
	mat.scale_min = 2.0; mat.scale_max = 4.0
	var grad = Gradient.new()
	grad.set_color(0, Color(0.2, 1.0, 0.2)); grad.set_color(1, Color(0.2, 1.0, 0.2, 0))
	var grad_tex = GradientTexture1D.new()
	grad_tex.gradient = grad
	mat.color_ramp = grad_tex
	p.process_material = mat
	return p

# --- NEW: DODGE PARTICLES (Ghostly Wind) ---
func _create_dodge_particles() -> GPUParticles2D:
	var p = GPUParticles2D.new()
	p.amount = 10
	p.lifetime = 0.5
	p.one_shot = true
	p.explosiveness = 0.8
	
	# Texture: Horizontal Streak
	var img = Image.create(16, 2, false, Image.FORMAT_RGBA8)
	img.fill(Color.WHITE)
	p.texture = ImageTexture.create_from_image(img)
	
	var mat = ParticleProcessMaterial.new()
	mat.direction = Vector3(0, 0, 0) # Just float
	mat.emission_shape = ParticleProcessMaterial.EMISSION_SHAPE_SPHERE
	mat.emission_sphere_radius = 40.0
	mat.gravity = Vector3(0, -50, 0) # Rise slightly
	mat.scale_min = 1.0
	mat.scale_max = 2.0
	
	# Color: White -> Transparent
	var grad = Gradient.new()
	grad.set_color(0, Color(0.8, 0.9, 1.0, 0.5)) # Misty Blue-White
	grad.set_color(1, Color(1, 1, 1, 0))
	var grad_tex = GradientTexture1D.new()
	grad_tex.gradient = grad
	mat.color_ramp = grad_tex
	
	p.process_material = mat
	return p

# --- NEW: SUPER PARTICLES (Rising Aura) ---
func _create_super_particles() -> GPUParticles2D:
	var p = GPUParticles2D.new()
	p.amount = 50
	p.lifetime = 1.5
	p.one_shot = true
	p.explosiveness = 0.0 # Stream
	
	var img = Image.create(4, 4, false, Image.FORMAT_RGBA8)
	img.fill(Color.WHITE)
	p.texture = ImageTexture.create_from_image(img)
	
	var mat = ParticleProcessMaterial.new()
	mat.emission_shape = ParticleProcessMaterial.EMISSION_SHAPE_BOX
	mat.emission_box_extents = Vector3(40, 10, 1) # Floor area
	mat.direction = Vector3(0, -1, 0) # Up
	mat.spread = 0
	mat.initial_velocity_min = 100
	mat.initial_velocity_max = 200
	mat.gravity = Vector3(0, 0, 0)
	
	# Color: Gold/Purple
	var grad = Gradient.new()
	grad.set_color(0, Color(1, 0.8, 0.2)) # Gold
	grad.set_color(1, Color(0.5, 0, 0.5, 0)) # Purple fade
	var grad_tex = GradientTexture1D.new()
	grad_tex.gradient = grad
	mat.color_ramp = grad_tex
	
	p.process_material = mat
	return p

# ==============================================================================
# SPAWN LOGIC
# ==============================================================================

func _get_target_pos(id: int) -> Vector2:
	var screen_size = get_viewport().get_visible_rect().size
	var y_pos = screen_size.y * 0.4 
	if id == 1: return Vector2(screen_size.x * 0.25, y_pos)
	else: return Vector2(screen_size.x * 0.75, y_pos)

func _spawn_vfx(particle_node: GPUParticles2D, pos: Vector2):
	particle_node.position = pos
	add_child(particle_node)
	particle_node.emitting = true
	await get_tree().create_timer(particle_node.lifetime + 0.1).timeout
	particle_node.queue_free()

func _on_clash_resolved(_winner_id, _p1_card, _p2_card, _log_info):
	# 1. Standard Clash Explosion
	var center = get_viewport().get_visible_rect().size / 2
	_spawn_vfx(_create_clash_particles(), center)
	
	# 2. CHECK FOR SUPER MOVES (Visual Juiciness)
	# We peek at the GameManager to see if a Super was used
	if GameManager.p1_action_queue and GameManager.p1_action_queue.is_super:
		_trigger_super_visuals(1)
	if GameManager.p2_action_queue and GameManager.p2_action_queue.is_super:
		_trigger_super_visuals(2)

func _trigger_super_visuals(player_id: int):
	# Darken screen slightly
	var dark = ColorRect.new()
	dark.set_anchors_and_offsets_preset(Control.PRESET_FULL_RECT)
	dark.color = Color.BLACK
	dark.modulate.a = 0.0
	add_child(dark)
	
	var tween = create_tween()
	tween.tween_property(dark, "modulate:a", 0.5, 0.2)
	tween.tween_property(dark, "modulate:a", 0.0, 0.5).set_delay(0.5)
	
	# Play Rising Aura
	var pos = _get_target_pos(player_id)
	# Shift aura down to feet
	pos.y += 100 
	_spawn_vfx(_create_super_particles(), pos)
	
	await tween.finished
	dark.queue_free()

func _on_damage_dealt(target_id: int, amount: int, is_blocked: bool):
	var pos = _get_target_pos(target_id)
	
	if is_blocked:
		_spawn_vfx(_create_block_particles(), pos)
		await get_tree().create_timer(0.1).timeout
		_spawn_vfx(_create_block_particles(), pos)
	elif amount > 0:
		_spawn_vfx(_create_hit_particles(), pos)

func _on_healing_received(target_id: int, _amount: int):
	var pos = _get_target_pos(target_id)
	_spawn_vfx(_create_heal_particles(), pos)

# NEW: Specific handler for Dodge
func _on_status_applied(target_id: int, status: String):
	if status == "DODGED":
		var pos = _get_target_pos(target_id)
		_spawn_vfx(_create_dodge_particles(), pos)

func _create_wall_debris() -> GPUParticles2D:
	var p = GPUParticles2D.new()
	p.amount = 20
	p.lifetime = 0.8
	p.one_shot = true
	p.explosiveness = 1.0
	
	# Texture: Grey Square (Concrete/Wood chip)
	var img = Image.create(6, 6, false, Image.FORMAT_RGBA8)
	img.fill(Color.LIGHT_GRAY)
	p.texture = ImageTexture.create_from_image(img)
	
	# Physics
	var mat = ParticleProcessMaterial.new()
	mat.direction = Vector3(1, -0.5, 0) # Default Right-Up
	mat.spread = 30
	mat.initial_velocity_min = 300
	mat.initial_velocity_max = 600
	mat.gravity = Vector3(0, 1500, 0) # Heavy falling debris
	mat.scale_min = 2.0
	mat.scale_max = 5.0
	
	# Rotation
	mat.angular_velocity_min = -300
	mat.angular_velocity_max = 300
	
	# Color: Grey -> Fade
	var grad = Gradient.new()
	grad.set_color(0, Color(0.7, 0.7, 0.7)) 
	grad.set_color(1, Color(0.7, 0.7, 0.7, 0))
	var grad_tex = GradientTexture1D.new()
	grad_tex.gradient = grad
	mat.color_ramp = grad_tex
	
	p.process_material = mat
	return p

func _on_wall_crush(target_id: int, _damage: int):
	var screen_size = get_viewport().get_visible_rect().size
	var spawn_pos = Vector2.ZERO
	
	var p = _create_wall_debris()
	var mat = p.process_material as ParticleProcessMaterial
	
	if target_id == 1:
		# P1 Hit LEFT Wall -> Debris flies RIGHT
		spawn_pos = Vector2(0, screen_size.y * 0.5) # Left Edge Center
		mat.direction = Vector3(1, -0.5, 0) # Fly Right-Up
	else:
		# P2 Hit RIGHT Wall -> Debris flies LEFT
		spawn_pos = Vector2(screen_size.x, screen_size.y * 0.5) # Right Edge Center
		mat.direction = Vector3(-1, -0.5, 0) # Fly Left-Up
		
	_spawn_vfx(p, spawn_pos)


========================================
FILE PATH: res://Scripts/VsScreen.gd
========================================
extends Control

@onready var background = $Background
@onready var p1_container = $Content/P1_Container
@onready var p1_portrait = $Content/P1_Container/Portrait
@onready var p1_name = $Content/P1_Container/NameLabel
@onready var p1_class = $Content/P1_Container/ClassLabel

@onready var p2_container = $Content/P2_Container
@onready var p2_portrait = $Content/P2_Container/Portrait
@onready var p2_name = $Content/P2_Container/NameLabel
@onready var p2_class = $Content/P2_Container/ClassLabel

@onready var vs_label = $Content/VsLabel
@onready var arena_label = $ArenaLabel

@onready var p1_bubble = $Content/P1_Container/PanelContainer/SpeechBubble # Adjust path if needed
@onready var p2_bubble = $Content/P2_Container/PanelContainer/SpeechBubble

func _ready():
	_setup_visuals()
	
	# Wait a frame to let Godot calculate the new Anchors we set
	await get_tree().process_frame
	_play_intro_animation()
	
	# Wait 3.5 seconds, then load the fight
	await get_tree().create_timer(5.0).timeout
	SceneLoader.change_scene("res://Scenes/MainScene.tscn")

func _setup_visuals():
	# -- Background --
	var env_name = GameManager.current_environment_name
	if GameManager.environment_backgrounds.has(env_name):
		background.texture = GameManager.environment_backgrounds[env_name]
	arena_label.text = "- " + env_name.to_upper() + " -"

	# -- Player 1 --
	var p1 = GameManager.next_match_p1_data
	if p1:
		p1_portrait.texture = p1.portrait
		p1_name.text = p1.character_name
		p1_class.text = CharacterData.ClassType.keys()[p1.class_type]

	# -- Player 2 --
	var p2 = GameManager.next_match_p2_data
	if p2:
		p2_portrait.texture = p2.portrait
		p2_portrait.flip_h = true 
		p2_name.text = p2.character_name
		if p2.character_name == "THE JUGGERNAUT": 
			p2_class.text = "BOSS"
			p2_class.modulate = Color.RED
		else:
			p2_class.text = CharacterData.ClassType.keys()[p2.class_type]

func _play_intro_animation():
	vs_label.scale = Vector2.ZERO
	
	# Get exact screen width
	var screen_w = get_viewport_rect().size.x
	
	# 1. DEFINE TARGETS (Where they should end up)
	# P1 is anchored to Left (0)
	var p1_target_x = 0
	# P2 is anchored to Center (Width / 2)
	var p2_target_x = screen_w / 2
	
	# 2. DEFINE START POSITIONS (Where they start)
	# Start P1 way off the left side
	p1_container.position.x = -p1_container.size.x
	# Start P2 way off the right side
	p2_container.position.x = screen_w
	
	# 3. ANIMATE
	var tween = create_tween().set_parallel(true)
	tween.set_trans(Tween.TRANS_EXPO)
	tween.set_ease(Tween.EASE_OUT)
	
	tween.tween_property(p1_container, "position:x", p1_target_x, 0.8)
	tween.tween_property(p2_container, "position:x", p2_target_x, 0.8)
	
	# Pop the VS Label
	tween.tween_property(vs_label, "scale", Vector2.ONE, 0.5).set_delay(0.6).set_trans(Tween.TRANS_ELASTIC)
	
	# --- NEW: TRIGGER DIALOGUE ---
	var p1_type = GameManager.next_match_p1_data.class_type
	var p2_type = GameManager.next_match_p2_data.class_type
	
	var banter = DialogueManager.get_intro_banter(p1_type, p2_type)
	
	# Set text
	p1_bubble.text = banter["p1"] # Assuming Bubble is a Panel with a Label child
	p2_bubble.text = banter["p2"]
	
	# Sequence: 
	# 1. Slide In (0.8s) -> 2. Show P1 Text (1.5s) -> 3. Show P2 Text (1.5s) -> 4. Fight
	
	await get_tree().create_timer(1.0).timeout
	p1_bubble.visible = true
	AudioManager.play_sfx("ui_hover") # Or a "speech" sound
	
	await get_tree().create_timer(1.5).timeout
	p2_bubble.visible = true
	AudioManager.play_sfx("ui_hover")
